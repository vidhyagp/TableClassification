<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="24" family="Times" color="#000000"/>
	<fontspec id="1" size="6" family="Times" color="#000000"/>
	<fontspec id="2" size="15" family="Times" color="#000000"/>
	<fontspec id="3" size="11" family="Times" color="#000000"/>
	<fontspec id="4" size="9" family="Times" color="#000000"/>
<text top="109" left="202" width="512" height="25" font="0"><b>Tuffy: Scaling up Statistical Inference in</b></text>
<text top="138" left="195" width="525" height="25" font="0"><b>Markov Logic Networks using an RDBMS</b></text>
<text top="145" left="720" width="6" height="8" font="1">∗</text>
<text top="207" left="186" width="72" height="17" font="2">Feng Niu</text>
<text top="207" left="309" width="121" height="17" font="2">Christopher Ré</text>
<text top="207" left="480" width="97" height="17" font="2">AnHai Doan</text>
<text top="207" left="628" width="101" height="17" font="2">Jude Shavlik</text>
<text top="234" left="336" width="259" height="17" font="2">University of Wisconsin-Madison</text>
<text top="255" left="298" width="7" height="13" font="3">{</text>
<text top="252" left="305" width="211" height="17" font="2">leonn,chrisre,anhai,shavlik</text>
<text top="255" left="516" width="7" height="13" font="3">}</text>
<text top="252" left="522" width="111" height="17" font="2">@cs.wisc.edu</text>
<text top="312" left="81" width="97" height="16" font="2">ABSTRACT</text>
<text top="337" left="81" width="359" height="14" font="3">Markov Logic Networks (MLNs) have emerged as a powerful</text>
<text top="352" left="81" width="359" height="12" font="3">framework that combines statistical and logical reasoning;</text>
<text top="368" left="81" width="359" height="12" font="3">they have been applied to many data intensive problems in-</text>
<text top="384" left="81" width="359" height="12" font="3">cluding information extraction, entity resolution, and text</text>
<text top="399" left="81" width="359" height="14" font="3">mining. Current implementations of MLNs do not scale to</text>
<text top="415" left="81" width="359" height="12" font="3">large real-world data sets, which is preventing their wide-</text>
<text top="431" left="81" width="359" height="14" font="3">spread adoption. We present Tuffy that achieves scalabil-</text>
<text top="446" left="81" width="359" height="12" font="3">ity via three novel contributions: (1) a bottom-up approach</text>
<text top="462" left="81" width="359" height="12" font="3">to grounding that allows us to leverage the full power of the</text>
<text top="478" left="81" width="359" height="12" font="3">relational optimizer, (2) a novel hybrid architecture that al-</text>
<text top="494" left="81" width="359" height="12" font="3">lows us to perform AI-style local search eﬃciently using an</text>
<text top="509" left="81" width="359" height="12" font="3">RDBMS, and (3) a theoretical insight that shows when one</text>
<text top="525" left="81" width="359" height="12" font="3">can (exponentially) improve the eﬃciency of stochastic local</text>
<text top="541" left="81" width="359" height="12" font="3">search. We leverage (3) to build novel partitioning, loading,</text>
<text top="556" left="81" width="359" height="12" font="3">and parallel algorithms. We show that our approach outper-</text>
<text top="572" left="81" width="359" height="12" font="3">forms state-of-the-art implementations in both quality and</text>
<text top="588" left="81" width="265" height="12" font="3">speed on several publicly available datasets.</text>
<text top="623" left="81" width="13" height="16" font="2">1.</text>
<text top="623" left="112" width="143" height="16" font="2">INTRODUCTION</text>
<text top="646" left="94" width="345" height="14" font="3">Over the past few years, Markov Logic Networks (MLNs)</text>
<text top="661" left="81" width="359" height="12" font="3">have emerged as a powerful and popular framework com-</text>
<text top="677" left="81" width="359" height="14" font="3">bining logical and probabilistic reasoning. MLNs have been</text>
<text top="693" left="81" width="359" height="12" font="3">successfully applied to a wide variety of data management</text>
<text top="709" left="81" width="359" height="12" font="3">problems, e.g., information extraction, entity resolution, and</text>
<text top="724" left="81" width="359" height="12" font="3">text mining. In contrast to probability models like factor</text>
<text top="740" left="81" width="359" height="12" font="3">graphs [23] that require complex distributions to be speci-</text>
<text top="756" left="81" width="359" height="14" font="3">ﬁed in tedious detail, MLNs allow us to declare a rigorous</text>
<text top="771" left="81" width="359" height="12" font="3">statistical model at a much higher conceptual level using</text>
<text top="787" left="81" width="359" height="12" font="3">ﬁrst-order logic. For example, to classify papers by research</text>
<text top="803" left="81" width="359" height="12" font="3">area, one could write a rule such as “it is likely that if one</text>
<text top="818" left="81" width="337" height="12" font="3">paper cites another they are in the same research area.”</text>
<text top="843" left="81" width="6" height="8" font="1">∗</text>
<text top="846" left="88" width="352" height="12" font="3">We gratefully acknowledge the support of Defense Ad-</text>
<text top="859" left="81" width="359" height="12" font="3">vanced Research Projects Agency (DARPA) Machine Read-</text>
<text top="873" left="81" width="359" height="12" font="3">ing Program under Air Force Research Laboratory (AFRL)</text>
<text top="886" left="81" width="359" height="12" font="3">prime contract no. FA8750-09-C-0181. Any opinions, ﬁnd-</text>
<text top="900" left="81" width="359" height="12" font="3">ings, and conclusion or recommendations expressed in this</text>
<text top="913" left="81" width="359" height="12" font="3">material are those of the authors and do not necessarily re-</text>
<text top="926" left="81" width="343" height="12" font="3">ﬂect the view of DARPA, AFRL, or the US government.</text>
<text top="950" left="81" width="359" height="11" font="4">Permission to make digital or hard copies of all or part of this work for</text>
<text top="964" left="81" width="359" height="11" font="4">personal or classroom use is granted without fee provided that copies are</text>
<text top="977" left="81" width="359" height="11" font="4">not made or distributed for proﬁt or commercial advantage and that copies</text>
<text top="990" left="81" width="359" height="11" font="4">bear this notice and the full citation on the ﬁrst page. To copy otherwise, to</text>
<text top="1004" left="81" width="359" height="11" font="4">republish, to post on servers or to redistribute to lists, requires prior speciﬁc</text>
<text top="1017" left="81" width="359" height="11" font="4">permission and/or a fee. Articles from this volume were invited to present</text>
<text top="1031" left="81" width="359" height="11" font="4">their results at The 37th International Conference on Very Large Data Bases,</text>
<text top="1044" left="81" width="270" height="11" font="4">August 29th - September 3rd 2011, Seattle, Washington.</text>
<text top="1058" left="81" width="184" height="10" font="4">Proceedings of the VLDB Endowment,</text>
<text top="1058" left="268" width="64" height="11" font="4">Vol. 4, No. 6</text>
<text top="1071" left="81" width="266" height="11" font="4">Copyright 2011 VLDB Endowment 2150-8097/11/03...</text>
<text top="1070" left="351" width="7" height="12" font="3">$</text>
<text top="1071" left="360" width="30" height="11" font="4">10.00.</text>
<text top="315" left="489" width="345" height="14" font="3">Our interest in MLNs stems from our involvement in a</text>
<text top="331" left="475" width="359" height="12" font="3">DARPA project called “Machine Reading.” The grand chal-</text>
<text top="346" left="475" width="359" height="12" font="3">lenge is to build software that can read the Web, i.e., extract</text>
<text top="362" left="475" width="359" height="12" font="3">and integrate structured data (e.g., entities, relationships)</text>
<text top="378" left="475" width="359" height="12" font="3">from Web data, then use this structured data to answer user</text>
<text top="393" left="475" width="359" height="14" font="3">queries. The current approach is to use MLNs as a lingua</text>
<text top="409" left="475" width="359" height="12" font="3">franca to combine many diﬀerent kinds of extractions into</text>
<text top="425" left="475" width="359" height="12" font="3">one coherent picture. To accomplish this goal, it is critical</text>
<text top="440" left="475" width="215" height="14" font="3">that MLNs scale to large data sets.</text>
<text top="456" left="489" width="345" height="14" font="3">Unfortunately, none of the current MLN implementations</text>
<text top="472" left="475" width="359" height="12" font="3">scale beyond relatively small data sets (and even on many</text>
<text top="488" left="475" width="359" height="12" font="3">of these data sets, existing implementations routinely take</text>
<text top="503" left="475" width="359" height="12" font="3">hours to run). The ﬁrst obvious reason is that these are in-</text>
<text top="519" left="475" width="359" height="12" font="3">memory implementations: when manipulating large inter-</text>
<text top="535" left="475" width="359" height="12" font="3">mediate data structures that overﬂow main memory, they</text>
<text top="550" left="475" width="183" height="12" font="3">either crash or thrash badly.</text>
<text top="550" left="673" width="161" height="12" font="3">Consequently, there is an</text>
<text top="566" left="475" width="359" height="12" font="3">emerging eﬀort across several research groups to scale up</text>
<text top="584" left="475" width="43" height="12" font="3">MLNs.</text>
<text top="582" left="531" width="293" height="14" font="3">In this paper, we describe our system, Tuffy</text>
<text top="579" left="824" width="5" height="8" font="1">1</text>
<text top="582" left="830" width="4" height="12" font="3">,</text>
<text top="597" left="475" width="359" height="12" font="3">that leverages an RDBMS to address the above scalability</text>
<text top="613" left="475" width="165" height="12" font="3">and performance problems.</text>
<text top="629" left="489" width="353" height="14" font="3">There are two aspects of MLNs: learning and inference [21].</text>
<text top="644" left="475" width="359" height="12" font="3">We focus on inference, since typically a model is learned</text>
<text top="660" left="475" width="359" height="12" font="3">once, and then an application may perform inference many</text>
<text top="676" left="475" width="359" height="12" font="3">times using the same model; hence inference is an on-line</text>
<text top="692" left="475" width="359" height="14" font="3">process, which must be fast. Moreover, MLN learning al-</text>
<text top="707" left="475" width="359" height="12" font="3">gorithms typically invoke inference as a subroutine repeat-</text>
<text top="723" left="475" width="177" height="12" font="3">edly. Conceptually, inference</text>
<text top="720" left="652" width="5" height="8" font="1">2</text>
<text top="723" left="663" width="170" height="14" font="3">in MLNs has two phases: a</text>
<text top="739" left="475" width="359" height="12" font="3">grounding phase, which constructs a large, weighted SAT</text>
<text top="754" left="475" width="359" height="12" font="3">formula, and a search phase, which searches for a low cost</text>
<text top="770" left="475" width="359" height="12" font="3">(weight) assignment (called a solution) to the SAT formula</text>
<text top="786" left="475" width="359" height="14" font="3">from grounding (using WalkSAT [13], a local search proce-</text>
<text top="801" left="475" width="359" height="12" font="3">dure). Grounding is a non-trivial portion of the overall in-</text>
<text top="817" left="475" width="359" height="12" font="3">ference eﬀort: on a classiﬁcation benchmark (called RC) the</text>
<text top="833" left="475" width="359" height="14" font="3">state-of-the-art MLN inference engine, Alchemy [7], spends</text>
<text top="848" left="475" width="359" height="12" font="3">over 96% of its execution time in grounding. The state-of-</text>
<text top="864" left="475" width="359" height="12" font="3">the-art strategy for the grounding phase (and the one used</text>
<text top="880" left="475" width="359" height="14" font="3">by Alchemy) is a top-down procedure (similar to the proof</text>
<text top="896" left="475" width="359" height="12" font="3">strategy in Prolog). In contrast, we propose a bottom-up</text>
<text top="911" left="475" width="359" height="12" font="3">grounding strategy. Intuitively, bottom-up grounding allows</text>
<text top="929" left="475" width="359" height="12" font="3">Tuffy to fully exploit the RDBMS optimizer, and thereby</text>
<text top="943" left="475" width="359" height="14" font="3">signiﬁcantly speed up the grounding phase of MLN infer-</text>
<text top="958" left="475" width="359" height="14" font="3">ence. On an entity resolution task, Alchemy takes over</text>
<text top="974" left="475" width="359" height="14" font="3">7 hours to complete grounding, while Tuffy’s grounding</text>
<text top="990" left="475" width="185" height="12" font="3">ﬁnishes in less than 2 minutes.</text>
<text top="1022" left="476" width="5" height="8" font="1">1</text>
<text top="1025" left="482" width="240" height="11" font="3">http://www.cs.wisc.edu/hazy/tuffy/</text>
<text top="1037" left="476" width="5" height="8" font="1">2</text>
<text top="1040" left="482" width="352" height="12" font="3">We focus on maximum a posteriori inference which is crit-</text>
<text top="1053" left="475" width="359" height="12" font="3">ical for many integration tasks. We discuss marginal infer-</text>
<text top="1067" left="475" width="135" height="12" font="3">ence in Appendix A.5.</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="5" size="14" family="Times" color="#000000"/>
<text top="86" left="94" width="345" height="12" font="3">But not all phases are well-optimized by the RDBMS: dur-</text>
<text top="102" left="81" width="359" height="12" font="3">ing the search phase, we found that the RDBMS implemen-</text>
<text top="118" left="81" width="359" height="12" font="3">tation performed poorly. The underlying reason is a funda-</text>
<text top="133" left="81" width="359" height="12" font="3">mental problem for pushing local search procedures into an</text>
<text top="149" left="81" width="359" height="12" font="3">RDBMS: search procedures often perform inherently sequen-</text>
<text top="165" left="81" width="170" height="12" font="3">tial, random data accesses.</text>
<text top="165" left="264" width="175" height="12" font="3">Consequently, any RDBMS-</text>
<text top="180" left="81" width="359" height="12" font="3">based solution must execute a large number of disk ac-</text>
<text top="196" left="81" width="359" height="12" font="3">cesses, each of which has a substantial overhead (due to the</text>
<text top="212" left="81" width="359" height="12" font="3">RDBMS) versus direct main-memory access. Not surpris-</text>
<text top="228" left="81" width="359" height="12" font="3">ingly, given the same amount of time, an in-memory solu-</text>
<text top="243" left="81" width="359" height="12" font="3">tion can execute between three and ﬁve orders of magnitude</text>
<text top="259" left="81" width="359" height="12" font="3">more search steps than an approach that uses an RDBMS.</text>
<text top="275" left="81" width="359" height="12" font="3">Thus, to achieve competitive performance, we developed a</text>
<text top="290" left="81" width="359" height="12" font="3">novel hybrid architecture that supports local search proce-</text>
<text top="306" left="81" width="359" height="12" font="3">dures in main memory whenever possible. This is our second</text>
<text top="322" left="81" width="136" height="12" font="3">technical contribution.</text>
<text top="337" left="94" width="345" height="12" font="3">Our third contribution is a simple partitioning technique</text>
<text top="353" left="81" width="359" height="14" font="3">that allows Tuffy to introduce parallelism and use less</text>
<text top="369" left="81" width="359" height="12" font="3">memory than state-of-the-art approaches. Surprisingly, this</text>
<text top="384" left="81" width="359" height="14" font="3">same technique often allows Tuffy to speed up the search</text>
<text top="400" left="81" width="359" height="12" font="3">phase exponentially. The underlying idea is simple: in many</text>
<text top="416" left="81" width="359" height="12" font="3">cases, a local search problem can be divided into multiple</text>
<text top="432" left="81" width="359" height="12" font="3">independent subproblems. For example, the formula that</text>
<text top="447" left="81" width="359" height="12" font="3">is output by the grounding phase may consist of multiple</text>
<text top="463" left="81" width="359" height="12" font="3">connected components. On such datasets, we derive a suf-</text>
<text top="479" left="81" width="359" height="12" font="3">ﬁcient condition under which solving the subproblems inde-</text>
<text top="494" left="81" width="359" height="12" font="3">pendently results in exponentially faster search than running</text>
<text top="510" left="81" width="359" height="12" font="3">the larger global problem (Thm. 3.1). An application of our</text>
<text top="526" left="81" width="359" height="12" font="3">theorem shows that on an information extraction testbed,</text>
<text top="541" left="81" width="359" height="12" font="3">a system that is not aware of this phenomenon (such as</text>
<text top="559" left="81" width="192" height="12" font="3">Alchemy) must take at least 2</text>
<text top="554" left="273" width="16" height="8" font="1">200</text>
<text top="557" left="295" width="144" height="14" font="3">more steps than Tuffy</text>
<text top="573" left="81" width="359" height="12" font="3">to reach a solution with the same quality. Empirically we</text>
<text top="588" left="81" width="359" height="12" font="3">found that, on some real-world datasets, solutions found by</text>
<text top="607" left="81" width="359" height="12" font="3">Tuffy within one minute have higher quality than those</text>
<text top="620" left="81" width="359" height="14" font="3">found by non-partitioning systems (such as Alchemy) even</text>
<text top="635" left="81" width="136" height="12" font="3">after running for days.</text>
<text top="651" left="94" width="345" height="12" font="3">The exponential diﬀerence in running time for indepen-</text>
<text top="667" left="81" width="359" height="12" font="3">dent subproblems versus the larger global problem suggests</text>
<text top="683" left="81" width="359" height="12" font="3">that in some cases, further decomposing the search space</text>
<text top="698" left="81" width="359" height="12" font="3">may improve the overall runtime. To implement this idea</text>
<text top="714" left="81" width="359" height="14" font="3">for MLNs, we must address two diﬃcult problems: (1) parti-</text>
<text top="730" left="81" width="359" height="12" font="3">tioning the formula from grounding (and so the search space)</text>
<text top="745" left="81" width="359" height="12" font="3">to minimize the number of formula that are split between</text>
<text top="761" left="81" width="359" height="12" font="3">partitions, and (2) augmenting the search algorithm to be</text>
<text top="777" left="81" width="359" height="12" font="3">aware of partitioning. We show that the ﬁrst problem is NP-</text>
<text top="792" left="81" width="359" height="12" font="3">hard (even to approximate), and design a scalable heuristic</text>
<text top="808" left="81" width="359" height="12" font="3">partitioning algorithm. For the second problem, we apply</text>
<text top="824" left="81" width="359" height="12" font="3">a technique from non-linear optimization to leverage the in-</text>
<text top="839" left="81" width="359" height="12" font="3">sights gained from our characterization of the phenomenon</text>
<text top="855" left="81" width="359" height="12" font="3">described above. The eﬀect of such partitioning is dramatic.</text>
<text top="871" left="81" width="359" height="12" font="3">As an example, on a classiﬁcation benchmark (called RC),</text>
<text top="889" left="81" width="359" height="12" font="3">Tuffy (using 15MB of RAM) produces much better result</text>
<text top="902" left="81" width="359" height="14" font="3">quality in minutes than Alchemy (using 2.8GB of RAM)</text>
<text top="918" left="81" width="359" height="14" font="3">even after days of running. In fact, Tuffy is able to an-</text>
<text top="934" left="81" width="359" height="12" font="3">swer queries on a version of the RC dataset that is over two</text>
<text top="949" left="81" width="359" height="14" font="3">orders of magnitude larger. (We estimate that Alchemy</text>
<text top="965" left="81" width="266" height="12" font="3">would need 280GB+ of RAM to process it.)</text>
<text top="997" left="81" width="93" height="14" font="5">Related Work.</text>
<text top="1001" left="181" width="258" height="12" font="3">MLNs are an integral part of state-of-the-</text>
<text top="1014" left="81" width="359" height="12" font="3">art approaches in a variety of applications: natural language</text>
<text top="1030" left="81" width="359" height="12" font="3">processing [22], ontology matching [29], information extrac-</text>
<text top="1046" left="81" width="359" height="12" font="3">tion [18], entity resolution [25], etc. And so, there is an</text>
<text top="1061" left="81" width="215" height="14" font="3">application push to support MLNs.</text>
<text top="86" left="489" width="345" height="12" font="3">Pushing statistical reasoning models inside a database sys-</text>
<text top="102" left="475" width="359" height="12" font="3">tem has been a goal of many projects [5, 10, 11, 20, 27]. Most</text>
<text top="118" left="475" width="359" height="14" font="3">closely related is the BayesStore project, in which the</text>
<text top="133" left="475" width="359" height="12" font="3">database essentially stores Bayes Nets [17] and allows these</text>
<text top="149" left="475" width="359" height="12" font="3">networks to be retrieved for inference by an external pro-</text>
<text top="165" left="475" width="359" height="14" font="3">gram. In contrast, Tuffy uses an RDBMS to optimize the</text>
<text top="180" left="475" width="359" height="12" font="3">inference procedure. The Monte-Carlo database [10] made</text>
<text top="196" left="475" width="359" height="12" font="3">sampling a ﬁrst-class citizen inside an RDBMS. In contrast,</text>
<text top="212" left="475" width="359" height="14" font="3">in Tuffy our approach can be viewed as pushing classical</text>
<text top="228" left="475" width="359" height="14" font="3">search inside the database engine. One way to view an MLN</text>
<text top="243" left="475" width="359" height="12" font="3">is a compact speciﬁcation of factor graphs [23]. Sen et al. [23]</text>
<text top="259" left="475" width="359" height="12" font="3">proposed new algorithms; in contrast, we take an existing,</text>
<text top="275" left="475" width="359" height="12" font="3">widely used class of algorithms (local search), and our focus</text>
<text top="290" left="475" width="311" height="12" font="3">is to leverage the RDBMS to improve performance.</text>
<text top="306" left="489" width="345" height="12" font="3">There has also been an extensive amount of work on prob-</text>
<text top="322" left="475" width="359" height="12" font="3">abilistic databases [1, 2, 4, 19] that deal with simpler proba-</text>
<text top="337" left="475" width="359" height="12" font="3">bilistic models. Finding the most likely world is trivial in</text>
<text top="353" left="475" width="359" height="14" font="3">these models; in contrast, it is highly non-trivial in MLNs</text>
<text top="369" left="475" width="160" height="12" font="3">(in fact, it is NP-hard [6]).</text>
<text top="369" left="647" width="187" height="12" font="3">Finally, none of these prior ap-</text>
<text top="384" left="475" width="359" height="14" font="3">proaches deal with the core technical challenge Tuffy ad-</text>
<text top="400" left="475" width="359" height="12" font="3">dresses, which is handling AI-style search inside a database.</text>
<text top="416" left="475" width="325" height="12" font="3">Additional related work can be found in Appendix D.</text>
<text top="448" left="475" width="262" height="14" font="5">Contributions, Validation, and Outline.</text>
<text top="449" left="744" width="90" height="12" font="3">To summarize,</text>
<text top="465" left="475" width="222" height="12" font="3">we make the following contributions:</text>
<text top="491" left="495" width="339" height="15" font="3">• In Section 3.1, we design a solution that pushes MLNs</text>
<text top="507" left="509" width="97" height="12" font="3">into RDBMSes.</text>
<text top="507" left="619" width="215" height="12" font="3">The key idea is to use bottom-up</text>
<text top="523" left="509" width="325" height="12" font="3">grounding that allows us to leverage the RDBMS opti-</text>
<text top="539" left="509" width="333" height="12" font="3">mizer; this idea improves the performance of the ground-</text>
<text top="554" left="509" width="251" height="12" font="3">ing phase by several orders of magnitude.</text>
<text top="572" left="495" width="339" height="13" font="3">• In Section 3.2, we devise a novel hybrid architecture to</text>
<text top="588" left="509" width="325" height="12" font="3">support eﬃcient grounding and in-memory inference.</text>
<text top="604" left="509" width="325" height="12" font="3">By itself, this architecture is far more scalable and,</text>
<text top="619" left="509" width="325" height="12" font="3">given the same amount of time, can perform orders of</text>
<text top="635" left="509" width="267" height="12" font="3">magnitude more search steps than prior art.</text>
<text top="652" left="495" width="339" height="13" font="3">• In Section 3.3, we describe novel data partitioning</text>
<text top="669" left="509" width="325" height="12" font="3">techniques to decrease the memory usage and to in-</text>
<text top="685" left="509" width="325" height="12" font="3">crease parallelism (and so improve the scalability) of</text>
<text top="703" left="509" width="325" height="12" font="3">Tuffy’s in-memory inference algorithms. Addition-</text>
<text top="716" left="509" width="325" height="12" font="3">ally, we show that for any MLN with an MRF that</text>
<text top="732" left="509" width="325" height="12" font="3">contains multiple components, partitioning could ex-</text>
<text top="747" left="509" width="325" height="12" font="3">ponentially improve the expected (average case) search</text>
<text top="763" left="509" width="31" height="12" font="3">time.</text>
<text top="780" left="495" width="339" height="13" font="3">• In Section 3.4, we generalize our partitioning results</text>
<text top="797" left="509" width="325" height="14" font="3">to arbitrary MLNs using our characterization of the</text>
<text top="812" left="509" width="325" height="12" font="3">partitioning phenomenon. These techniques result in</text>
<text top="828" left="509" width="300" height="12" font="3">our highest quality, most space-eﬃcient solutions.</text>
<text top="854" left="475" width="359" height="12" font="3">We present an extensive experimental study on a diverse set</text>
<text top="870" left="475" width="359" height="14" font="3">of MLN testbeds to demonstrate that our system Tuffy is</text>
<text top="886" left="475" width="359" height="12" font="3">able to get better result quality more quickly and work over</text>
<text top="902" left="475" width="315" height="12" font="3">larger datasets than the state-of-the-art approaches.</text>
<text top="934" left="475" width="13" height="16" font="2">2.</text>
<text top="934" left="507" width="146" height="16" font="2">PRELIMINARIES</text>
<text top="957" left="489" width="345" height="12" font="3">We illustrate a Markov Logic Network program using the</text>
<text top="973" left="475" width="359" height="12" font="3">example of classifying papers by topic area. We then deﬁne</text>
<text top="988" left="475" width="336" height="14" font="3">the semantics of MLNs and the mechanics of inference.</text>
<text top="1013" left="475" width="22" height="16" font="2">2.1</text>
<text top="1013" left="516" width="160" height="16" font="2">The Syntax of MLNs</text>
<text top="1035" left="489" width="347" height="14" font="3">Figure 1 shows an example input MLN program for Tuffy</text>
<text top="1051" left="475" width="359" height="12" font="3">that is used to classify paper references by topic area, such</text>
<text top="1067" left="475" width="359" height="12" font="3">as databases, systems, AI, etc. In this example, a user gives</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
<text top="96" left="138" width="123" height="10" font="4">paper(PaperID, URL)</text>
<text top="110" left="139" width="122" height="10" font="4">wrote(Author, Paper)</text>
<text top="123" left="139" width="121" height="10" font="4">refers(Paper, Paper)</text>
<text top="137" left="140" width="120" height="10" font="4">cat(Paper, Category)</text>
<text top="82" left="282" width="36" height="11" font="4">weight</text>
<text top="82" left="334" width="21" height="11" font="4">rule</text>
<text top="95" left="297" width="6" height="11" font="4">5</text>
<text top="96" left="334" width="179" height="10" font="4">cat(p, c1), cat(p, c2) =&gt; c1 = c2</text>
<text top="95" left="628" width="13" height="11" font="4">(F</text>
<text top="99" left="641" width="5" height="8" font="1">1</text>
<text top="95" left="647" width="5" height="11" font="4">)</text>
<text top="109" left="297" width="6" height="11" font="4">1</text>
<text top="110" left="334" width="278" height="10" font="4">wrote(x, p1), wrote(x, p2), cat(p1, c) =&gt; cat(p2, c)</text>
<text top="109" left="628" width="13" height="11" font="4">(F</text>
<text top="112" left="641" width="5" height="8" font="1">2</text>
<text top="109" left="647" width="5" height="11" font="4">)</text>
<text top="122" left="297" width="6" height="11" font="4">2</text>
<text top="123" left="334" width="217" height="10" font="4">cat(p1, c), refers(p1, p2) =&gt; cat(p2, c)</text>
<text top="122" left="628" width="13" height="11" font="4">(F</text>
<text top="126" left="641" width="5" height="8" font="1">3</text>
<text top="122" left="647" width="5" height="11" font="4">)</text>
<text top="136" left="289" width="23" height="11" font="4">+∞</text>
<text top="137" left="334" width="170" height="10" font="4">paper(p, u) =&gt; ∃x. wrote(x, p)</text>
<text top="136" left="628" width="13" height="11" font="4">(F</text>
<text top="139" left="641" width="5" height="8" font="1">4</text>
<text top="136" left="647" width="5" height="11" font="4">)</text>
<text top="149" left="295" width="11" height="11" font="4">-1</text>
<text top="150" left="334" width="112" height="10" font="4">cat(p, ‘Networking’)</text>
<text top="149" left="628" width="13" height="11" font="4">(F</text>
<text top="153" left="641" width="5" height="8" font="1">5</text>
<text top="149" left="647" width="5" height="11" font="4">)</text>
<text top="83" left="673" width="97" height="10" font="4">wrote(‘Joe’, ‘P1’)</text>
<text top="96" left="673" width="97" height="10" font="4">wrote(‘Joe’, ‘P2’)</text>
<text top="110" left="673" width="103" height="10" font="4">wrote(‘Jake’, ‘P3’)</text>
<text top="123" left="673" width="100" height="10" font="4">refers(‘P1’, ‘P3’)</text>
<text top="137" left="673" width="84" height="10" font="4">cat(‘P2’, ‘DB’)</text>
<text top="148" left="673" width="15" height="11" font="4">· · ·</text>
<text top="163" left="179" width="42" height="11" font="4">Schema</text>
<text top="163" left="396" width="142" height="11" font="4">A Markov Logic Program</text>
<text top="163" left="700" width="50" height="11" font="4">Evidence</text>
<text top="192" left="81" width="753" height="12" font="3">Figure 1: A Sample Markov Logic Program: The goal is to classify papers by area. As evidence we are given</text>
<text top="208" left="81" width="753" height="12" font="3">author and citation information of all papers, as well as the labels of a subset of the papers; we want to</text>
<text top="223" left="81" width="650" height="12" font="3">classify the remaining papers. Any variable not explicitly quantiﬁed is universally quantiﬁed.</text>
<text top="255" left="81" width="359" height="12" font="3">Tuffy a set of relations that capture information about the</text>
<text top="268" left="81" width="359" height="12" font="3">papers in her dataset: she has extracted authors and cita-</text>
<text top="284" left="81" width="359" height="12" font="3">tions and stored them in the relations wrote(Author,Paper)</text>
<text top="300" left="81" width="359" height="12" font="3">and refers(Paper,Paper). She may also provide evidence,</text>
<text top="316" left="81" width="359" height="12" font="3">which is data that she knows to be true (or false). Here, the</text>
<text top="331" left="81" width="359" height="12" font="3">evidence shows that Joe wrote papers P1 and P2 and P1</text>
<text top="347" left="81" width="359" height="12" font="3">cited another paper P3. In the relation cat (for ‘category’),</text>
<text top="363" left="81" width="359" height="14" font="3">she provides Tuffy with a subset of papers and the cate-</text>
<text top="378" left="81" width="359" height="12" font="3">gories into which they fall. The cat relation is incomplete:</text>
<text top="394" left="81" width="359" height="12" font="3">some papers are not labeled. We can think of each possi-</text>
<text top="410" left="81" width="359" height="12" font="3">ble labeling of these papers as an instantiation of the cat</text>
<text top="425" left="81" width="359" height="12" font="3">relation, which can be viewed as a possible world [8]. The</text>
<text top="441" left="81" width="359" height="12" font="3">classiﬁcation task is to ﬁnd the most likely labeling of papers</text>
<text top="457" left="81" width="336" height="12" font="3">by topic area, and hence the most likely possible world.</text>
<text top="472" left="94" width="345" height="12" font="3">To tell the system which possible world it should produce,</text>
<text top="488" left="81" width="359" height="12" font="3">the user provides (in addition to the above data) a set of</text>
<text top="504" left="81" width="335" height="12" font="3">rules that incorporate her knowledge of the problem.</text>
<text top="504" left="429" width="10" height="12" font="3">A</text>
<text top="520" left="81" width="148" height="12" font="3">simple example rule is F</text>
<text top="524" left="228" width="5" height="8" font="1">1</text>
<text top="520" left="235" width="4" height="12" font="3">:</text>
<text top="546" left="143" width="195" height="11" font="3">cat(p, c1), cat(p, c2) =&gt; c1 = c2</text>
<text top="545" left="352" width="14" height="12" font="3">(F</text>
<text top="550" left="366" width="5" height="8" font="1">1</text>
<text top="545" left="372" width="5" height="12" font="3">)</text>
<text top="571" left="85" width="78" height="12" font="3">Intuitively, F</text>
<text top="576" left="164" width="5" height="8" font="1">1</text>
<text top="571" left="174" width="265" height="12" font="3">says that a paper should be in one category.</text>
<text top="587" left="81" width="359" height="14" font="3">In MLNs, this rule may be hard, meaning that it behaves</text>
<text top="603" left="81" width="359" height="12" font="3">like a standard key constraint: in any possible world, each</text>
<text top="618" left="81" width="359" height="12" font="3">paper must be in at most one category. This rule may also</text>
<text top="634" left="81" width="359" height="12" font="3">be soft, meaning that it may be violated in some possible</text>
<text top="650" left="81" width="359" height="12" font="3">worlds. For example, in some worlds a paper may be in two</text>
<text top="665" left="81" width="359" height="12" font="3">categories. Soft rules also have weights that intuitively tell</text>
<text top="681" left="81" width="359" height="12" font="3">us how likely the rule is to hold in a possible world. In this</text>
<text top="697" left="81" width="68" height="12" font="3">example, F</text>
<text top="701" left="148" width="5" height="8" font="1">1</text>
<text top="697" left="160" width="280" height="12" font="3">is a soft rule and has weight 5. Roughly, this</text>
<text top="712" left="81" width="239" height="12" font="3">means that a ﬁxed paper is at least e</text>
<text top="710" left="320" width="5" height="8" font="1">5</text>
<text top="712" left="333" width="107" height="12" font="3">times more likely</text>
<text top="728" left="81" width="359" height="12" font="3">to be in a single category compared to being in multiple</text>
<text top="744" left="81" width="359" height="14" font="3">categories. MLNs can also involve data in non-trivial ways,</text>
<text top="759" left="81" width="359" height="12" font="3">we refer the reader to Appendix A.1 for a more complete</text>
<text top="775" left="81" width="65" height="12" font="3">exposition.</text>
<text top="807" left="81" width="93" height="14" font="5">Query Model.</text>
<text top="809" left="181" width="258" height="12" font="3">Given the data and the rules, a user may</text>
<text top="824" left="81" width="359" height="14" font="3">write arbitrary queries in terms of the relations. In Tuffy,</text>
<text top="840" left="81" width="359" height="12" font="3">the system is responsible for ﬁlling in whatever missing data</text>
<text top="856" left="81" width="359" height="12" font="3">is needed: in this example, the category of each unlabeled</text>
<text top="871" left="81" width="359" height="12" font="3">paper is unknown, and so to answer a query the system infers</text>
<text top="887" left="81" width="336" height="12" font="3">the most likely labels for each paper from the evidence.</text>
<text top="913" left="81" width="22" height="16" font="2">2.2</text>
<text top="913" left="121" width="150" height="16" font="2">Semantics of MLNs</text>
<text top="935" left="94" width="345" height="14" font="3">We describe the semantics of MLNs. Formally, we ﬁrst</text>
<text top="951" left="81" width="359" height="12" font="3">ﬁx a schema σ (as in Figure 1) and a domain D. Given as</text>
<text top="967" left="81" width="154" height="12" font="3">input a set of formula ¯</text>
<text top="967" left="224" width="43" height="12" font="3">F = F</text>
<text top="971" left="267" width="5" height="8" font="1">1</text>
<text top="967" left="274" width="40" height="12" font="3">, . . . , F</text>
<text top="971" left="313" width="9" height="8" font="1">N</text>
<text top="967" left="330" width="98" height="12" font="3">(in clausal form</text>
<text top="964" left="428" width="5" height="8" font="1">3</text>
<text top="967" left="434" width="5" height="12" font="3">)</text>
<text top="982" left="81" width="90" height="12" font="3">with weights w</text>
<text top="987" left="171" width="5" height="8" font="1">1</text>
<text top="982" left="177" width="41" height="12" font="3">, . . . , w</text>
<text top="987" left="217" width="9" height="8" font="1">N</text>
<text top="982" left="228" width="212" height="12" font="3">, they deﬁne a probability distribu-</text>
<text top="998" left="81" width="359" height="12" font="3">tion over possible worlds (deterministic databases). To con-</text>
<text top="1014" left="81" width="359" height="12" font="3">struct this probability distribution, the ﬁrst step is ground-</text>
<text top="1037" left="81" width="5" height="8" font="1">3</text>
<text top="1040" left="88" width="352" height="12" font="3">Clausal form is a disjunction of positive or negative literals.</text>
<text top="1053" left="81" width="359" height="12" font="3">For example, the rule is R(a) =&gt; R(b) is not in clausal form,</text>
<text top="1067" left="81" width="358" height="12" font="3">but is equivalent to ¬R(a) ∨ R(b), which is in clausal form.</text>
<text top="253" left="475" width="260" height="12" font="3">ing: given a formula F with free variables ¯</text>
<text top="253" left="728" width="39" height="12" font="3">x = (x</text>
<text top="257" left="767" width="5" height="8" font="1">1</text>
<text top="253" left="773" width="41" height="12" font="3">, · · · , x</text>
<text top="257" left="814" width="10" height="8" font="1">m</text>
<text top="253" left="825" width="9" height="12" font="3">),</text>
<text top="268" left="475" width="97" height="12" font="3">then for each ¯</text>
<text top="268" left="563" width="39" height="12" font="3">d ∈ D</text>
<text top="266" left="602" width="10" height="8" font="1">m</text>
<text top="268" left="613" width="174" height="12" font="3">, we create a new formula g</text>
<text top="272" left="789" width="5" height="8" font="1">¯</text>
<text top="275" left="787" width="6" height="8" font="1">d</text>
<text top="268" left="799" width="35" height="12" font="3">called</text>
<text top="284" left="475" width="152" height="12" font="3">a ground clause where g</text>
<text top="288" left="629" width="5" height="8" font="1">¯</text>
<text top="290" left="627" width="6" height="8" font="1">d</text>
<text top="284" left="640" width="194" height="12" font="3">denotes the result of substitut-</text>
<text top="300" left="475" width="121" height="12" font="3">ing each variable x</text>
<text top="304" left="596" width="4" height="8" font="1">i</text>
<text top="300" left="608" width="77" height="12" font="3">of F with d</text>
<text top="304" left="685" width="4" height="8" font="1">i</text>
<text top="300" left="690" width="4" height="12" font="3">.</text>
<text top="300" left="707" width="121" height="12" font="3">For example, for F</text>
<text top="304" left="828" width="5" height="8" font="1">3</text>
<text top="316" left="475" width="345" height="12" font="3">the variables are {p1, p2, c}: one tuple of constants is ¯</text>
<text top="316" left="810" width="23" height="12" font="3">d =</text>
<text top="331" left="475" width="259" height="12" font="3">(‘P1’, ‘P2’, ‘DB’) and the ground formula f</text>
<text top="335" left="736" width="5" height="8" font="1">¯</text>
<text top="337" left="734" width="6" height="8" font="1">d</text>
<text top="331" left="745" width="13" height="12" font="3">is:</text>
<text top="358" left="493" width="323" height="11" font="3">cat(‘P1’, ‘DB’), refers(‘P1’, ‘P2’) =&gt; cat(‘P2’, ‘DB’)</text>
<text top="383" left="480" width="354" height="12" font="3">Each constituent in the ground formula, such as cat(‘P1’,</text>
<text top="399" left="475" width="359" height="12" font="3">‘DB’) and refers(‘P1’, ‘P2’), is called a ground predicate</text>
<text top="414" left="475" width="304" height="12" font="3">or atom for short. In the worst case there are D</text>
<text top="412" left="780" width="5" height="8" font="1">3</text>
<text top="414" left="792" width="42" height="12" font="3">ground</text>
<text top="430" left="475" width="75" height="12" font="3">clauses for F</text>
<text top="435" left="550" width="5" height="8" font="1">3</text>
<text top="430" left="556" width="123" height="12" font="3">. For each formula F</text>
<text top="435" left="679" width="4" height="8" font="1">i</text>
<text top="430" left="688" width="146" height="12" font="3">(for i = 1 . . . N ), we per-</text>
<text top="446" left="475" width="359" height="12" font="3">form the above process. Each ground clause g of a formula</text>
<text top="461" left="475" width="9" height="12" font="3">F</text>
<text top="466" left="484" width="4" height="8" font="1">i</text>
<text top="461" left="494" width="188" height="12" font="3">is assigned the same weight, w</text>
<text top="466" left="682" width="4" height="8" font="1">i</text>
<text top="461" left="686" width="148" height="12" font="3">. So, a ground clause of</text>
<text top="477" left="475" width="9" height="12" font="3">F</text>
<text top="482" left="484" width="5" height="8" font="1">1</text>
<text top="477" left="495" width="263" height="12" font="3">has weight 5, while any ground clause of F</text>
<text top="482" left="758" width="5" height="8" font="1">2</text>
<text top="477" left="770" width="64" height="12" font="3">has weight</text>
<text top="493" left="475" width="147" height="12" font="3">1. We denote by G = (¯</text>
<text top="493" left="615" width="219" height="12" font="3">g, w) the set of all ground clauses of</text>
<text top="505" left="478" width="7" height="12" font="3">¯</text>
<text top="509" left="475" width="359" height="12" font="3">F and a function w that maps each ground clause to its as-</text>
<text top="524" left="475" width="184" height="14" font="3">signed weight. Fix an MLN ¯</text>
<text top="524" left="650" width="184" height="12" font="3">F , then for any possible world</text>
<text top="540" left="475" width="359" height="12" font="3">(instance) I we say a ground clause g is violated if w(g) &gt; 0</text>
<text top="556" left="475" width="359" height="12" font="3">and g is false in I or if w(g) &lt; 0 and g is true in I. We</text>
<text top="571" left="475" width="359" height="12" font="3">denote the set of ground clauses violated in a world I as</text>
<text top="587" left="475" width="194" height="12" font="3">V (I). The cost of the world I is</text>
<text top="616" left="587" width="56" height="12" font="3">cost(I) =</text>
<text top="636" left="647" width="36" height="8" font="1">g∈V (I)</text>
<text top="615" left="686" width="36" height="13" font="3">|w(g)|</text>
<text top="616" left="816" width="18" height="12" font="3">(1)</text>
<text top="657" left="475" width="359" height="14" font="3">Through cost, an MLN deﬁnes a probability distribution</text>
<text top="673" left="475" width="215" height="12" font="3">over all instances (denoted Inst) as:</text>
<text top="702" left="475" width="57" height="12" font="3">Pr[I] = Z</text>
<text top="698" left="534" width="14" height="8" font="1">−1</text>
<text top="702" left="551" width="162" height="12" font="3">exp {−cost(I)} where Z =</text>
<text top="721" left="716" width="33" height="8" font="1">J ∈Inst</text>
<text top="702" left="752" width="92" height="12" font="3">exp {−cost(J )}</text>
<text top="741" left="475" width="359" height="12" font="3">A lowest cost world I is called a most likely world. Since</text>
<text top="757" left="475" width="359" height="12" font="3">cost(I) ≥ 0, if cost(I) = 0 then I is a most likely world. On</text>
<text top="773" left="475" width="359" height="12" font="3">the other hand the most likely world may have positive cost.</text>
<text top="788" left="475" width="359" height="14" font="3">There are two main types of inference with MLNs: MAP</text>
<text top="804" left="475" width="359" height="12" font="3">(maximum a posteriori) inference, where we want to ﬁnd a</text>
<text top="820" left="475" width="359" height="12" font="3">most likely world, and marginal inference, where we want to</text>
<text top="835" left="475" width="359" height="14" font="3">compute marginal probabilities. Tuffy is capable of both</text>
<text top="851" left="475" width="359" height="12" font="3">types of inference, but we present only MAP inference in the</text>
<text top="867" left="475" width="359" height="12" font="3">body of this paper. We refer the reader to Appendix A.5 for</text>
<text top="882" left="475" width="174" height="12" font="3">details of marginal inference.</text>
<text top="908" left="475" width="22" height="16" font="2">2.3</text>
<text top="908" left="516" width="72" height="16" font="2">Inference</text>
<text top="931" left="489" width="345" height="14" font="3">We now describe the state of the art of inference for MLNs</text>
<text top="946" left="475" width="330" height="14" font="3">(as in Alchemy, the reference MLN implementation).</text>
<text top="971" left="475" width="75" height="14" font="5">Grounding.</text>
<text top="972" left="558" width="276" height="12" font="3">Conceptually, to obtain the ground clauses of</text>
<text top="988" left="475" width="359" height="14" font="3">an MLN formula F , the most straightforward way is to</text>
<text top="1004" left="475" width="359" height="12" font="3">enumerate all possible assignments to the free variables in</text>
<text top="1020" left="475" width="359" height="12" font="3">F . There have been several heuristics in the literature that</text>
<text top="1035" left="475" width="359" height="12" font="3">improve the grounding process by pruning groundings that</text>
<text top="1051" left="475" width="359" height="12" font="3">have no eﬀect on inference results; we describe the heuristics</text>
<text top="1067" left="475" width="359" height="14" font="3">that Tuffy (and Alchemy) implements in Appendix A.3.</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="81" width="359" height="12" font="3">The set of ground clauses corresponds to a hypergraph where</text>
<text top="102" left="81" width="359" height="12" font="3">each atom is a node and each clause is a hyperedge. This</text>
<text top="118" left="81" width="370" height="12" font="3">graph structure is often called a Markov Random Field (MRF).</text>
<text top="133" left="81" width="323" height="12" font="3">We describe this structure formally in Appendix A.2.</text>
<text top="165" left="81" width="49" height="14" font="5">Search.</text>
<text top="167" left="137" width="302" height="14" font="3">Finding a most likely world of an MLN is a general-</text>
<text top="183" left="81" width="359" height="12" font="3">ization of the (NP-hard) MaxSAT problem. In this paper we</text>
<text top="198" left="81" width="359" height="12" font="3">concentrate on one of the most popular heuristic search al-</text>
<text top="214" left="81" width="359" height="14" font="3">gorithms, WalkSAT [13], which is used by Alchemy. Walk-</text>
<text top="230" left="81" width="359" height="12" font="3">SAT works by repeatedly selecting a random violated clause</text>
<text top="245" left="81" width="359" height="12" font="3">and “ﬁxing” it by ﬂipping (i.e., changing the truth value of)</text>
<text top="261" left="81" width="359" height="12" font="3">an atom in it (see Appendix A.4). As with any heuristic</text>
<text top="277" left="81" width="359" height="12" font="3">search, we cannot be sure that we have achieved the op-</text>
<text top="293" left="81" width="359" height="12" font="3">timal, and so the goal of any system that executes such a</text>
<text top="308" left="81" width="359" height="12" font="3">search procedure is: execute more search steps in the same</text>
<text top="324" left="81" width="97" height="12" font="3">amount of time.</text>
<text top="356" left="81" width="142" height="14" font="5">Problem Description.</text>
<text top="358" left="230" width="210" height="12" font="3">The primary challenge that we ad-</text>
<text top="373" left="81" width="359" height="12" font="3">dress in this paper is scaling both phases of MAP inference</text>
<text top="389" left="81" width="359" height="12" font="3">algorithms, grounding and search, using an RDBMS. Sec-</text>
<text top="405" left="81" width="359" height="12" font="3">ond, our goal is to improve the number of (eﬀective) steps</text>
<text top="420" left="81" width="359" height="12" font="3">of the local search procedure using parallelism and partition-</text>
<text top="436" left="81" width="359" height="12" font="3">ing – but only when it provably improves the search quality.</text>
<text top="452" left="81" width="359" height="12" font="3">To achieve these goals, we attack three main technical chal-</text>
<text top="467" left="81" width="359" height="14" font="3">lenges: (1) eﬃciently grounding large MLNs, (2) eﬃciently</text>
<text top="483" left="81" width="359" height="14" font="3">performing inference (search) on large MLNs, and (3) de-</text>
<text top="499" left="81" width="359" height="12" font="3">signing partitioning and partition-aware search algorithms</text>
<text top="514" left="81" width="317" height="12" font="3">that preserve (or enhance) search quality and speed.</text>
<text top="554" left="81" width="13" height="16" font="2">3.</text>
<text top="554" left="112" width="148" height="16" font="2">TUFFY SYSTEMS</text>
<text top="577" left="94" width="345" height="12" font="3">In this section, we describe our technical contributions: a</text>
<text top="592" left="81" width="359" height="12" font="3">bottom-up grounding approach to fully leverage the RDBMS</text>
<text top="608" left="81" width="359" height="12" font="3">(Section 3.1); a hybrid main-memory RDBMS architecture</text>
<text top="624" left="81" width="359" height="12" font="3">to support eﬃcient end-to-end inference (Section 3.2); and</text>
<text top="639" left="81" width="364" height="14" font="3">data partitioning which dramatically improves Tuffy’s space</text>
<text top="655" left="81" width="296" height="12" font="3">and time eﬃciency (Section 3.3 and Section 3.4).</text>
<text top="683" left="81" width="22" height="16" font="2">3.1</text>
<text top="683" left="121" width="304" height="16" font="2">Grounding with a Bottom-up Approach</text>
<text top="706" left="94" width="345" height="14" font="3">We describe how Tuffy performs grounding. In con-</text>
<text top="721" left="81" width="359" height="12" font="3">trast to top-down approaches (similar to Prolog) that em-</text>
<text top="737" left="81" width="359" height="12" font="3">ploy nested loops and that is used by prior MLN systems</text>
<text top="753" left="81" width="359" height="14" font="3">such as Alchemy, Tuﬀy takes a bottom-up approach (sim-</text>
<text top="768" left="81" width="359" height="12" font="3">ilar to Datalog) by expressing grounding as a sequence of</text>
<text top="784" left="81" width="359" height="12" font="3">SQL queries. Each SQL query is optimized by the RDBMS,</text>
<text top="800" left="81" width="359" height="14" font="3">which allows Tuffy to complete the grounding process or-</text>
<text top="816" left="81" width="332" height="12" font="3">ders of magnitude more quickly than prior approaches.</text>
<text top="831" left="94" width="138" height="12" font="3">For each predicate P ( ¯</text>
<text top="831" left="222" width="218" height="14" font="3">A) in the input MLN, Tuffy creates</text>
<text top="847" left="81" width="74" height="12" font="3">a relation R</text>
<text top="852" left="155" width="7" height="8" font="1">P</text>
<text top="847" left="164" width="44" height="12" font="3">(aid, ¯</text>
<text top="847" left="197" width="169" height="12" font="3">A, truth) where each row a</text>
<text top="852" left="367" width="6" height="8" font="1">p</text>
<text top="847" left="379" width="61" height="12" font="3">represents</text>
<text top="863" left="81" width="283" height="12" font="3">an atom, aid is a globally unique identiﬁer, ¯</text>
<text top="863" left="354" width="86" height="12" font="3">A is the tuple</text>
<text top="878" left="81" width="359" height="12" font="3">of arguments of P , and truth is a three-valued attribute</text>
<text top="894" left="81" width="108" height="12" font="3">that indicates if a</text>
<text top="899" left="189" width="6" height="8" font="1">p</text>
<text top="894" left="200" width="239" height="12" font="3">is true or false (in the evidence), or not</text>
<text top="910" left="81" width="359" height="12" font="3">speciﬁed in the evidence. These tables form the input to</text>
<text top="925" left="81" width="359" height="14" font="3">grounding, and Tuffy constructs them using standard bulk-</text>
<text top="941" left="81" width="115" height="12" font="3">loading techniques.</text>
<text top="957" left="94" width="345" height="14" font="3">In Tuffy, we produce an output table C(cid, lits, weight)</text>
<text top="972" left="81" width="359" height="12" font="3">where each row corresponds to a single ground clause. Here,</text>
<text top="988" left="81" width="359" height="12" font="3">cid is the id of a ground clause, lits is an array that stores</text>
<text top="1004" left="81" width="359" height="12" font="3">the atom id of each literal in this clause (and whether or</text>
<text top="1020" left="81" width="359" height="12" font="3">not it is negated), and weight is the weight of this clause.</text>
<text top="1035" left="81" width="359" height="12" font="3">We ﬁrst consider a formula without existential quantiﬁers.</text>
<text top="1051" left="81" width="309" height="12" font="3">In this case, the formula F can be written as F (¯</text>
<text top="1051" left="382" width="38" height="12" font="3">x) = l</text>
<text top="1056" left="420" width="5" height="8" font="1">1</text>
<text top="1050" left="430" width="9" height="13" font="3">∨</text>
<text top="1066" left="81" width="36" height="13" font="3">· · · ∨ l</text>
<text top="1071" left="117" width="9" height="8" font="1">N</text>
<text top="1067" left="133" width="48" height="12" font="3">where ¯</text>
<text top="1067" left="173" width="266" height="14" font="3">x are all variables in F . Tuffy produces a</text>
<text top="86" left="475" width="359" height="12" font="3">SQL query Q for F that joins together the relations corre-</text>
<text top="102" left="475" width="359" height="12" font="3">sponding to the predicates in F to produce the atom ids of</text>
<text top="118" left="475" width="359" height="12" font="3">the ground clauses (and whether or not they are negated).</text>
<text top="133" left="475" width="359" height="12" font="3">The join conditions in Q enforce variable equality inside</text>
<text top="149" left="475" width="359" height="12" font="3">F , and incorporate the pruning strategies described in Ap-</text>
<text top="165" left="475" width="359" height="12" font="3">pendix A.3. For more details on the compilation procedure</text>
<text top="180" left="475" width="110" height="12" font="3">see Appendix B.1.</text>
<text top="224" left="475" width="22" height="16" font="2">3.2</text>
<text top="224" left="516" width="278" height="16" font="2">A Hybrid Architecture for Inference</text>
<text top="247" left="489" width="345" height="12" font="3">Our initial prototype of Tuﬀy runs both grounding and</text>
<text top="263" left="475" width="359" height="12" font="3">search in the RDBMS. While the grounding phase described</text>
<text top="278" left="475" width="359" height="12" font="3">in the previous section has good performance and scalabil-</text>
<text top="294" left="475" width="359" height="12" font="3">ity, we found that performing search in an RDBMS is often</text>
<text top="310" left="475" width="359" height="12" font="3">a bottleneck. Thus, we design a hybrid architecture that</text>
<text top="325" left="475" width="359" height="12" font="3">allows eﬃcient in-memory search (in Java) while retaining</text>
<text top="341" left="475" width="359" height="12" font="3">the performance beneﬁts of RDBMS-based grounding. To</text>
<text top="357" left="475" width="359" height="12" font="3">see why in-memory search is critical, recall that WalkSAT</text>
<text top="372" left="475" width="359" height="12" font="3">works by selecting an unsatisﬁed clause C, selecting an atom</text>
<text top="388" left="475" width="359" height="12" font="3">in C, and “ﬂipping” that atom to satisfy C. Thus, Walk-</text>
<text top="404" left="475" width="359" height="12" font="3">SAT performs a large number of random accesses to the</text>
<text top="420" left="475" width="359" height="12" font="3">data representing ground clauses and atoms. Moreover, the</text>
<text top="435" left="475" width="359" height="12" font="3">data that is accessed in one iteration depends on the data</text>
<text top="451" left="475" width="359" height="12" font="3">that is accessed in the previous iteration. And so, this ac-</text>
<text top="467" left="475" width="359" height="12" font="3">cess pattern prevents both eﬀective caching and parallelism,</text>
<text top="482" left="475" width="359" height="12" font="3">which causes a high overhead per data access. Thus, we</text>
<text top="498" left="475" width="359" height="12" font="3">implement a hybrid architecture where the RDBMS per-</text>
<text top="514" left="475" width="359" height="14" font="3">forms grounding and Tuffy is able to read the result of</text>
<text top="529" left="475" width="359" height="12" font="3">grounding from the RDBMS into memory and perform in-</text>
<text top="545" left="475" width="359" height="12" font="3">ference. If the grounding result is too large to ﬁt in memory,</text>
<text top="563" left="475" width="359" height="12" font="3">Tuffy invokes an implementation of search directly inside</text>
<text top="576" left="475" width="359" height="12" font="3">the RDBMS (Appendix B.2). This approach is much less ef-</text>
<text top="592" left="475" width="359" height="12" font="3">ﬁcient than in-memory search, but it runs on datasets larger</text>
<text top="608" left="475" width="359" height="12" font="3">than main memory without crashing. Appendix B.3 illus-</text>
<text top="624" left="475" width="291" height="14" font="3">trates the architecture of Tuffy in more detail.</text>
<text top="639" left="489" width="345" height="12" font="3">While it is clear that this hybrid approach is at least</text>
<text top="655" left="475" width="359" height="12" font="3">as scalable as a direct memory implementation (such as</text>
<text top="673" left="475" width="359" height="12" font="3">Alchemy), there are in fact cases where Tuffy can run</text>
<text top="686" left="475" width="359" height="14" font="3">in-memory search whereas Alchemy would crash. The rea-</text>
<text top="702" left="475" width="359" height="12" font="3">son is that the space requirement of a purely in-memory im-</text>
<text top="718" left="475" width="359" height="12" font="3">plementation is determined by the peak memory footprint</text>
<text top="733" left="475" width="359" height="14" font="3">throughout grounding and search, whereas Tuffy needs</text>
<text top="749" left="475" width="359" height="12" font="3">main memory only for search. For example, on a dataset</text>
<text top="765" left="475" width="359" height="14" font="3">called Relational Classiﬁcation (RC), Alchemy allocated</text>
<text top="780" left="475" width="359" height="12" font="3">2.8 GB of RAM only to produce 4.8 MB of ground clauses.</text>
<text top="796" left="475" width="256" height="14" font="3">On RC, Tuffy uses only 19 MB of RAM.</text>
<text top="840" left="475" width="22" height="16" font="2">3.3</text>
<text top="840" left="516" width="285" height="16" font="2">Partitioning to Improve Performance</text>
<text top="863" left="489" width="345" height="12" font="3">In the following two sections, we study how to further im-</text>
<text top="878" left="475" width="359" height="14" font="3">prove Tuffy’s space and time eﬃciency without sacriﬁcing</text>
<text top="894" left="475" width="359" height="12" font="3">its scalability. The underlying idea is simple: we will try</text>
<text top="910" left="475" width="359" height="12" font="3">to partition the data. By splitting the problem into smaller</text>
<text top="925" left="475" width="359" height="12" font="3">pieces, we can reduce the memory footprint and introduce</text>
<text top="941" left="475" width="359" height="12" font="3">parallelism, which conceptually breaks the sequential nature</text>
<text top="957" left="475" width="359" height="12" font="3">of the search. These are expected beneﬁts of partitioning.</text>
<text top="972" left="475" width="359" height="12" font="3">An unexpected beneﬁt is an exponentially increase of the</text>
<text top="988" left="475" width="333" height="12" font="3">eﬀective search speed, a point that we return to below.</text>
<text top="1004" left="489" width="345" height="14" font="3">First, observe that the logical forms of MLNs often re-</text>
<text top="1020" left="475" width="359" height="12" font="3">sult in an MRF with multiple disjoint components (see Ap-</text>
<text top="1035" left="475" width="359" height="12" font="3">pendix B.4). For example, on the RC dataset there are 489</text>
<text top="1051" left="475" width="303" height="12" font="3">components. Let G be an MRF with components G</text>
<text top="1056" left="779" width="5" height="8" font="1">1</text>
<text top="1051" left="785" width="44" height="12" font="3">, · · · , G</text>
<text top="1056" left="829" width="6" height="8" font="1">k</text>
<text top="1051" left="835" width="4" height="12" font="3">;</text>
<text top="1067" left="475" width="307" height="12" font="3">let I be a truth assignment to the atoms in G and I</text>
<text top="1071" left="782" width="4" height="8" font="1">i</text>
<text top="1067" left="791" width="43" height="12" font="3">its pro-</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="6" size="5" family="Times" color="#000000"/>
	<fontspec id="7" size="12" family="Times" color="#000000"/>
<text top="86" left="81" width="85" height="12" font="3">jection over G</text>
<text top="91" left="166" width="4" height="8" font="1">i</text>
<text top="86" left="171" width="150" height="12" font="3">. Then, it’s clear that ∀I</text>
<text top="114" left="176" width="24" height="12" font="3">cost</text>
<text top="110" left="200" width="9" height="8" font="1">G</text>
<text top="114" left="209" width="32" height="12" font="3">(I) =</text>
<text top="133" left="246" width="33" height="8" font="1">1≤i≤k</text>
<text top="114" left="281" width="24" height="12" font="3">cost</text>
<text top="110" left="305" width="9" height="8" font="1">G</text>
<text top="113" left="313" width="4" height="7" font="6">i</text>
<text top="114" left="319" width="11" height="12" font="3">(I</text>
<text top="118" left="330" width="4" height="8" font="1">i</text>
<text top="114" left="335" width="9" height="12" font="3">).</text>
<text top="156" left="81" width="212" height="12" font="3">Hence, instead of minimizing cost</text>
<text top="153" left="292" width="9" height="8" font="1">G</text>
<text top="156" left="302" width="138" height="12" font="3">(I) directly, it suﬃces</text>
<text top="171" left="81" width="196" height="12" font="3">to minimize each individual cost</text>
<text top="169" left="277" width="9" height="8" font="1">G</text>
<text top="172" left="285" width="4" height="7" font="6">i</text>
<text top="171" left="291" width="11" height="12" font="3">(I</text>
<text top="176" left="302" width="4" height="8" font="1">i</text>
<text top="171" left="307" width="133" height="12" font="3">). The beneﬁt is that,</text>
<text top="187" left="81" width="359" height="12" font="3">even if G itself does not ﬁt in memory, it is possible that</text>
<text top="203" left="81" width="41" height="12" font="3">each G</text>
<text top="207" left="121" width="4" height="8" font="1">i</text>
<text top="203" left="130" width="206" height="12" font="3">does. As such, we can solve each G</text>
<text top="207" left="336" width="4" height="8" font="1">i</text>
<text top="203" left="344" width="95" height="12" font="3">with in-memory</text>
<text top="218" left="81" width="346" height="12" font="3">search one by one, and ﬁnally merge the results together.</text>
<text top="216" left="433" width="5" height="8" font="1">4</text>
<text top="234" left="94" width="345" height="12" font="3">Component detection is done after the grounding phase</text>
<text top="250" left="81" width="359" height="12" font="3">and before the search phase, as follows. We maintain an in-</text>
<text top="266" left="81" width="359" height="12" font="3">memory union-ﬁnd structure over the nodes, and scan the</text>
<text top="281" left="81" width="359" height="12" font="3">clause table while updating this union-ﬁnd structure. The</text>
<text top="297" left="81" width="359" height="12" font="3">result is the set of connected components in the MRF. An</text>
<text top="313" left="81" width="335" height="12" font="3">immediate issue raised by partitioning is I/O eﬃciency.</text>
<text top="345" left="81" width="151" height="14" font="5">Efﬁcient Data Loading.</text>
<text top="346" left="240" width="200" height="12" font="3">Once an MRF is split into compo-</text>
<text top="362" left="81" width="359" height="12" font="3">nents, loading in and running inference on each component</text>
<text top="378" left="81" width="359" height="12" font="3">sequentially one by one may incur many I/O operations,</text>
<text top="393" left="81" width="359" height="12" font="3">as there may be many partitions. For example, the MRF</text>
<text top="409" left="81" width="359" height="12" font="3">of the Information Extraction (IE) dataset contains thou-</text>
<text top="425" left="81" width="359" height="12" font="3">sands of 2-cliques and 3-cliques. One solution is to group</text>
<text top="440" left="81" width="359" height="12" font="3">the components into batches. The goal is to minimize the</text>
<text top="456" left="81" width="359" height="12" font="3">total number of batches (and thereby the I/O cost of load-</text>
<text top="472" left="81" width="359" height="12" font="3">ing), and the constraint is that each batch cannot exceed the</text>
<text top="487" left="81" width="359" height="12" font="3">memory budget. This is essentially the bin packing problem,</text>
<text top="503" left="81" width="359" height="12" font="3">and we implement the First Fit Decreasing algorithm [26].</text>
<text top="519" left="81" width="359" height="12" font="3">Once the partitions are in memory, we can take advantage</text>
<text top="535" left="81" width="332" height="12" font="3">of parallelism. We use a round-robin scheduling policy.</text>
<text top="566" left="81" width="295" height="14" font="5">Improving Search Speed using Partitioning.</text>
<text top="568" left="383" width="56" height="12" font="3">Although</text>
<text top="584" left="81" width="359" height="12" font="3">processing each component individually produces solutions</text>
<text top="600" left="81" width="359" height="12" font="3">that are no worse than processing the whole graph at once,</text>
<text top="615" left="81" width="359" height="12" font="3">we give an example to illustrate that component-aware pro-</text>
<text top="631" left="81" width="349" height="12" font="3">cessing may result in exponentially faster speed of search.</text>
<text top="661" left="81" width="359" height="12" font="3">Example 1 Consider an MRF consisting of N identical</text>
<text top="677" left="81" width="328" height="12" font="3">connected components each containing two atoms {X</text>
<text top="681" left="409" width="4" height="8" font="1">i</text>
<text top="677" left="414" width="14" height="12" font="3">, Y</text>
<text top="681" left="428" width="4" height="8" font="1">i</text>
<text top="676" left="432" width="7" height="13" font="3">}</text>
<text top="692" left="81" width="161" height="12" font="3">and three weighted clauses</text>
<text top="716" left="167" width="24" height="13" font="3">{(X</text>
<text top="722" left="191" width="4" height="8" font="1">i</text>
<text top="717" left="196" width="38" height="12" font="3">, 1), (Y</text>
<text top="722" left="234" width="4" height="8" font="1">i</text>
<text top="717" left="239" width="41" height="12" font="3">, 1), (X</text>
<text top="722" left="280" width="4" height="8" font="1">i</text>
<text top="716" left="288" width="20" height="13" font="3">∨ Y</text>
<text top="722" left="308" width="4" height="8" font="1">i</text>
<text top="717" left="313" width="40" height="12" font="3">, −1)},</text>
<text top="742" left="81" width="359" height="12" font="3">where i = 1 . . . N and the second component of each tuple</text>
<text top="758" left="81" width="359" height="12" font="3">is the weight. Based on how WalkSAT works, it’s not hard</text>
<text top="774" left="81" width="359" height="12" font="3">to show that, if N = 1, starting from a random state, the</text>
<text top="789" left="81" width="130" height="12" font="3">expected hitting time</text>
<text top="787" left="211" width="5" height="8" font="1">5</text>
<text top="789" left="222" width="164" height="12" font="3">of the optimal state, i.e. X</text>
<text top="794" left="385" width="5" height="8" font="1">1</text>
<text top="789" left="396" width="23" height="12" font="3">= Y</text>
<text top="794" left="418" width="5" height="8" font="1">1</text>
<text top="789" left="429" width="11" height="12" font="3">=</text>
<text top="805" left="81" width="359" height="12" font="3">T rue, is no more than 4. Therefore, if we run WalkSAT on</text>
<text top="821" left="81" width="359" height="12" font="3">each component separately, the expected runtime of reach-</text>
<text top="836" left="81" width="359" height="12" font="3">ing the optimum is no more than 4N . Now consider the</text>
<text top="852" left="81" width="359" height="12" font="3">case where we run WalkSAT on the whole MRF. Intuitively,</text>
<text top="868" left="81" width="359" height="12" font="3">reaching the optimal state requires “ﬁxing” suboptimal com-</text>
<text top="883" left="81" width="359" height="12" font="3">ponents one by one. As the number of optimal components</text>
<text top="899" left="81" width="359" height="12" font="3">increases, however, it becomes more and more likely that</text>
<text top="915" left="81" width="359" height="12" font="3">one step of WalkSAT “breaks” an optimal component in-</text>
<text top="930" left="81" width="359" height="12" font="3">stead of ﬁxing a suboptimal component. Such check and</text>
<text top="946" left="81" width="359" height="12" font="3">balance makes it very diﬃcult for WalkSAT to reach the</text>
<text top="968" left="81" width="5" height="8" font="1">4</text>
<text top="973" left="88" width="352" height="12" font="3">Alchemy exploits knowledge-based model construction</text>
<text top="984" left="81" width="359" height="12" font="3">(KBMC) [28] to ﬁnd the minimal subgraph of the MRF that</text>
<text top="997" left="81" width="359" height="14" font="3">is needed for a given query. Alchemy, however, does not</text>
<text top="1011" left="81" width="359" height="12" font="3">use the fact that the MRF output by KBMC may contain</text>
<text top="1024" left="81" width="121" height="12" font="3">several components.</text>
<text top="1037" left="81" width="5" height="8" font="1">5</text>
<text top="1040" left="88" width="352" height="12" font="3">The hitting time is a standard notion from Markov</text>
<text top="1053" left="81" width="359" height="12" font="3">Chains [9], it is a random variable for the number of steps</text>
<text top="1067" left="81" width="355" height="12" font="3">taken by WalkSAT to reach an optimum for the ﬁrst time.</text>
<text top="86" left="475" width="359" height="12" font="3">optimum. Indeed, Appendix B.5 shows that the expected</text>
<text top="102" left="475" width="147" height="12" font="3">hitting time is at least 2</text>
<text top="99" left="622" width="9" height="8" font="1">N</text>
<text top="102" left="637" width="130" height="12" font="3">– an exponential gap!</text>
<text top="134" left="475" width="222" height="12" font="3">Let G be an MRF with components G</text>
<text top="139" left="698" width="5" height="8" font="1">1</text>
<text top="134" left="704" width="42" height="12" font="3">, . . . , G</text>
<text top="139" left="745" width="9" height="8" font="1">N</text>
<text top="134" left="756" width="83" height="12" font="3">. Component-</text>
<text top="150" left="475" width="336" height="12" font="3">aware WalkSAT runs WalkSAT except that for each G</text>
<text top="155" left="811" width="4" height="8" font="1">i</text>
<text top="150" left="816" width="18" height="12" font="3">, it</text>
<text top="166" left="475" width="359" height="12" font="3">keeps track of the lowest-cost state it has found so far on</text>
<text top="181" left="475" width="43" height="12" font="3">that G</text>
<text top="186" left="518" width="4" height="8" font="1">i</text>
<text top="181" left="523" width="311" height="12" font="3">. In contrast, regular WalkSAT simply keeps the</text>
<text top="197" left="475" width="359" height="12" font="3">best overall solution it has seen so far. For i = 1, . . . , N ,</text>
<text top="213" left="475" width="31" height="12" font="3">let O</text>
<text top="217" left="506" width="4" height="8" font="1">i</text>
<text top="213" left="516" width="200" height="12" font="3">be the set of optimal states of G</text>
<text top="217" left="717" width="4" height="8" font="1">i</text>
<text top="213" left="721" width="45" height="12" font="3">, and S</text>
<text top="217" left="766" width="4" height="8" font="1">i</text>
<text top="213" left="776" width="58" height="12" font="3">the set of</text>
<text top="229" left="475" width="148" height="12" font="3">non-optimal states of G</text>
<text top="233" left="623" width="4" height="8" font="1">i</text>
<text top="229" left="634" width="200" height="12" font="3">that diﬀer only by one bit from</text>
<text top="244" left="475" width="42" height="12" font="3">some x</text>
<text top="241" left="517" width="6" height="8" font="1">∗</text>
<text top="243" left="527" width="24" height="13" font="3">∈ O</text>
<text top="249" left="551" width="4" height="8" font="1">i</text>
<text top="244" left="556" width="36" height="12" font="3">; let P</text>
<text top="249" left="592" width="4" height="8" font="1">i</text>
<text top="244" left="597" width="237" height="12" font="3">(x → y) be the transition probability of</text>
<text top="260" left="475" width="144" height="12" font="3">WalkSAT running on G</text>
<text top="264" left="620" width="4" height="8" font="1">i</text>
<text top="260" left="624" width="210" height="12" font="3">, i.e., the probability that one step</text>
<text top="276" left="475" width="159" height="12" font="3">of WalkSAT would take G</text>
<text top="280" left="634" width="4" height="8" font="1">i</text>
<text top="276" left="643" width="191" height="12" font="3">from x to y. Given x, a state of</text>
<text top="291" left="475" width="11" height="12" font="3">G</text>
<text top="296" left="486" width="4" height="8" font="1">i</text>
<text top="291" left="491" width="79" height="12" font="3">, denote by v</text>
<text top="296" left="569" width="4" height="8" font="1">i</text>
<text top="291" left="574" width="238" height="12" font="3">(x) the number of violated clauses in G</text>
<text top="296" left="812" width="4" height="8" font="1">i</text>
<text top="291" left="822" width="12" height="12" font="3">at</text>
<text top="307" left="475" width="85" height="12" font="3">state x; deﬁne</text>
<text top="336" left="509" width="9" height="12" font="3">α</text>
<text top="341" left="517" width="4" height="8" font="1">i</text>
<text top="336" left="522" width="33" height="12" font="3">(x) =</text>
<text top="355" left="559" width="22" height="8" font="1">y∈O</text>
<text top="358" left="581" width="4" height="7" font="6">i</text>
<text top="336" left="588" width="9" height="12" font="3">P</text>
<text top="341" left="597" width="4" height="8" font="1">i</text>
<text top="336" left="602" width="65" height="12" font="3">(x → y), β</text>
<text top="341" left="667" width="4" height="8" font="1">i</text>
<text top="336" left="671" width="33" height="12" font="3">(x) =</text>
<text top="355" left="708" width="20" height="8" font="1">y∈S</text>
<text top="358" left="729" width="4" height="7" font="6">i</text>
<text top="336" left="736" width="9" height="12" font="3">P</text>
<text top="341" left="745" width="4" height="8" font="1">i</text>
<text top="336" left="749" width="51" height="12" font="3">(x → y).</text>
<text top="378" left="475" width="301" height="12" font="3">For any non-empty subset H ⊆ {1, . . . , N }, deﬁne</text>
<text top="412" left="544" width="44" height="12" font="3">r(H) =</text>
<text top="404" left="596" width="23" height="12" font="3">min</text>
<text top="408" left="619" width="20" height="8" font="1">i∈H</text>
<text top="404" left="643" width="23" height="12" font="3">min</text>
<text top="408" left="666" width="22" height="8" font="1">x∈O</text>
<text top="411" left="688" width="4" height="7" font="6">i</text>
<text top="404" left="696" width="7" height="12" font="3">v</text>
<text top="408" left="703" width="4" height="8" font="1">i</text>
<text top="404" left="708" width="26" height="12" font="3">(x)β</text>
<text top="408" left="734" width="4" height="8" font="1">i</text>
<text top="404" left="739" width="19" height="12" font="3">(x)</text>
<text top="421" left="594" width="26" height="12" font="3">max</text>
<text top="426" left="619" width="20" height="8" font="1">i∈H</text>
<text top="421" left="644" width="26" height="12" font="3">max</text>
<text top="426" left="669" width="21" height="8" font="1">x∈S</text>
<text top="429" left="690" width="4" height="7" font="6">i</text>
<text top="421" left="698" width="7" height="12" font="3">v</text>
<text top="426" left="704" width="4" height="8" font="1">i</text>
<text top="421" left="709" width="27" height="12" font="3">(x)α</text>
<text top="426" left="737" width="4" height="8" font="1">i</text>
<text top="421" left="741" width="19" height="12" font="3">(x)</text>
<text top="412" left="762" width="4" height="12" font="3">.</text>
<text top="455" left="490" width="344" height="12" font="3">Theorem 3.1. Let H be an arbitrary non-empty subset of</text>
<text top="467" left="475" width="359" height="13" font="3">{1, . . . , N } s.t. |H| ≥ 2 and r = r(H) &gt; 0. Then, in expec-</text>
<text top="485" left="475" width="233" height="12" font="3">tation, WalkSAT on G takes at least 2</text>
<text top="482" left="708" width="56" height="8" font="1">|H|r/(2+r)</text>
<text top="485" left="770" width="64" height="12" font="3">more steps</text>
<text top="501" left="475" width="359" height="12" font="3">to ﬁnd an optimal solution than component-aware WalkSAT.</text>
<text top="533" left="475" width="359" height="12" font="3">The proof is in Appendix B.5. In the worst case, there is</text>
<text top="549" left="475" width="359" height="12" font="3">only one component, or r(H) = 0 for every subset of compo-</text>
<text top="565" left="475" width="359" height="12" font="3">nents H (which happens only if there is a zero-cost solution),</text>
<text top="580" left="475" width="359" height="12" font="3">and partitioning would become pure overhead (but negli-</text>
<text top="596" left="475" width="162" height="12" font="3">gible in our experiments).</text>
<text top="596" left="649" width="184" height="12" font="3">On an information extraction</text>
<text top="612" left="475" width="359" height="12" font="3">(IE) benchmark dataset, there is some H with |H| = 1196</text>
<text top="628" left="475" width="359" height="12" font="3">and r(H) = 0.5. Thus, the gap on this dataset is at least</text>
<text top="643" left="475" width="7" height="12" font="3">2</text>
<text top="641" left="482" width="16" height="8" font="1">200</text>
<text top="643" left="503" width="29" height="13" font="3">≈ 10</text>
<text top="641" left="532" width="11" height="8" font="1">60</text>
<text top="643" left="544" width="290" height="14" font="3">. This explains why Tuffy produces lower cost</text>
<text top="659" left="475" width="359" height="12" font="3">solutions in minutes than non-partition aware approaches</text>
<text top="675" left="475" width="260" height="14" font="3">such as Alchemy produce even after days.</text>
<text top="701" left="475" width="22" height="16" font="2">3.4</text>
<text top="701" left="516" width="210" height="16" font="2">Further Partitioning MRFs</text>
<text top="724" left="489" width="345" height="12" font="3">Although our algorithms are more scalable than prior ap-</text>
<text top="739" left="475" width="359" height="12" font="3">proaches, if the largest component does not ﬁt in memory</text>
<text top="755" left="475" width="359" height="12" font="3">then we are forced to run the in-RDBMS version of inference,</text>
<text top="771" left="475" width="359" height="12" font="3">which is ineﬃcient. Intuitively, if the graph is only weakly</text>
<text top="786" left="475" width="359" height="12" font="3">connected, then we should still be able to get the exponential</text>
<text top="802" left="475" width="352" height="12" font="3">speed up of partitioning. Consider the following example.</text>
<text top="852" left="722" width="20" height="15" font="7">G1 </text>
<text top="852" left="793" width="20" height="15" font="7">G2 </text>
<text top="845" left="763" width="10" height="13" font="3">e </text>
<text top="857" left="744" width="9" height="13" font="3">a </text>
<text top="857" left="782" width="10" height="13" font="3">b </text>
<text top="903" left="713" width="106" height="12" font="3">Figure 2: Ex. 2</text>
<text top="831" left="475" width="187" height="12" font="3">Example 2 Consider an MRF</text>
<text top="847" left="475" width="187" height="12" font="3">consisting of two equally sized</text>
<text top="863" left="475" width="77" height="12" font="3">subgraphs G</text>
<text top="867" left="552" width="5" height="8" font="1">1</text>
<text top="863" left="564" width="38" height="12" font="3">and G</text>
<text top="867" left="602" width="5" height="8" font="1">2</text>
<text top="863" left="608" width="54" height="12" font="3">, plus an</text>
<text top="878" left="475" width="187" height="12" font="3">edge e = (a, b) between them</text>
<text top="894" left="475" width="67" height="12" font="3">(Figure 2).</text>
<text top="894" left="555" width="108" height="12" font="3">Suppose that the</text>
<text top="910" left="475" width="187" height="12" font="3">expected hitting time of Walk-</text>
<text top="925" left="475" width="60" height="12" font="3">SAT on G</text>
<text top="930" left="535" width="4" height="8" font="1">i</text>
<text top="925" left="544" width="25" height="12" font="3">is H</text>
<text top="930" left="569" width="4" height="8" font="1">i</text>
<text top="925" left="573" width="57" height="12" font="3">. Since H</text>
<text top="930" left="630" width="5" height="8" font="1">1</text>
<text top="925" left="640" width="22" height="12" font="3">and</text>
<text top="941" left="475" width="11" height="12" font="3">H</text>
<text top="946" left="487" width="5" height="8" font="1">2</text>
<text top="941" left="496" width="338" height="12" font="3">are essentially independent, the hitting time of WalkSAT</text>
<text top="957" left="475" width="153" height="12" font="3">on G could be roughly H</text>
<text top="961" left="628" width="5" height="8" font="1">1</text>
<text top="957" left="634" width="11" height="12" font="3">H</text>
<text top="961" left="646" width="5" height="8" font="1">2</text>
<text top="957" left="652" width="182" height="12" font="3">. On the other hand, consider</text>
<text top="972" left="475" width="359" height="12" font="3">the following scheme: enumerate all possible truth assign-</text>
<text top="988" left="475" width="359" height="12" font="3">ments to one of the boundary variables {a, b}, say a – of</text>
<text top="1004" left="475" width="359" height="12" font="3">which there are two – and conditioning on each assignment,</text>
<text top="1020" left="475" width="123" height="12" font="3">run WalkSAT on G</text>
<text top="1024" left="598" width="5" height="8" font="1">1</text>
<text top="1020" left="611" width="39" height="12" font="3">and G</text>
<text top="1024" left="650" width="5" height="8" font="1">2</text>
<text top="1020" left="663" width="171" height="12" font="3">independently. Clearly, the</text>
<text top="1035" left="475" width="252" height="12" font="3">overall hitting time is no more than 2(H</text>
<text top="1040" left="727" width="5" height="8" font="1">1</text>
<text top="1035" left="737" width="26" height="12" font="3">+ H</text>
<text top="1040" left="763" width="5" height="8" font="1">2</text>
<text top="1035" left="769" width="65" height="12" font="3">), which is</text>
<text top="1051" left="475" width="170" height="12" font="3">a huge improvement over H</text>
<text top="1056" left="645" width="5" height="8" font="1">1</text>
<text top="1051" left="651" width="11" height="12" font="3">H</text>
<text top="1056" left="663" width="5" height="8" font="1">2</text>
<text top="1051" left="674" width="46" height="12" font="3">since H</text>
<text top="1056" left="720" width="4" height="8" font="1">i</text>
<text top="1051" left="729" width="105" height="12" font="3">is usually a high-</text>
<text top="1067" left="475" width="323" height="12" font="3">order polynomial or even exponential in the size of G</text>
<text top="1071" left="798" width="4" height="8" font="1">i</text>
<text top="1067" left="803" width="4" height="12" font="3">.</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="8" size="7" family="Times" color="#000000"/>
	<fontspec id="9" size="8" family="Times" color="#000000"/>
	<fontspec id="10" size="10" family="Times" color="#000000"/>
	<fontspec id="11" size="10" family="Times" color="#000000"/>
	<fontspec id="12" size="7" family="Times" color="#000000"/>
<text top="86" left="94" width="345" height="12" font="3">To capitalize on this idea, we need to address two chal-</text>
<text top="102" left="81" width="359" height="12" font="3">lenges: 1) designing an eﬃcient MRF partitioning algo-</text>
<text top="118" left="81" width="359" height="12" font="3">rithm; and 2) designing an eﬀective partition-aware search</text>
<text top="133" left="81" width="270" height="12" font="3">algorithm. We address each of them in turn.</text>
<text top="165" left="81" width="125" height="14" font="5">MRF Partitioning.</text>
<text top="167" left="213" width="227" height="12" font="3">Intuitively, to maximally utilize the</text>
<text top="183" left="81" width="359" height="12" font="3">memory budget, we want to partition the MRF into roughly</text>
<text top="198" left="81" width="359" height="12" font="3">equal sizes; to minimize information loss, we want to min-</text>
<text top="214" left="81" width="359" height="12" font="3">imize total weight of clauses that span over multiple parti-</text>
<text top="230" left="81" width="359" height="12" font="3">tions, i.e., the cut size. To capture this notion, we deﬁne a</text>
<text top="245" left="81" width="359" height="12" font="3">balanced bisection of a hypergraph G = (V, E) as a partition</text>
<text top="261" left="81" width="53" height="12" font="3">of V = V</text>
<text top="266" left="134" width="5" height="8" font="1">1</text>
<text top="260" left="142" width="19" height="13" font="3">∪ V</text>
<text top="266" left="161" width="5" height="8" font="1">2</text>
<text top="261" left="172" width="72" height="12" font="3">such that |V</text>
<text top="266" left="244" width="5" height="8" font="1">1</text>
<text top="260" left="250" width="34" height="13" font="3">| = |V</text>
<text top="266" left="284" width="5" height="8" font="1">2</text>
<text top="260" left="290" width="149" height="13" font="3">|. The cost of a bisection</text>
<text top="277" left="81" width="13" height="12" font="3">(V</text>
<text top="281" left="94" width="5" height="8" font="1">1</text>
<text top="277" left="100" width="14" height="12" font="3">, V</text>
<text top="281" left="115" width="5" height="8" font="1">2</text>
<text top="277" left="121" width="103" height="12" font="3">) is |{e ∈ E|e ∩ V</text>
<text top="281" left="223" width="5" height="8" font="1">1</text>
<text top="277" left="233" width="83" height="12" font="3">= ∅ and e ∩ V</text>
<text top="281" left="316" width="5" height="8" font="1">2</text>
<text top="277" left="326" width="36" height="12" font="3">= ∅}|.</text>
<text top="308" left="96" width="344" height="12" font="3">Theorem 3.2. Consider the MLN Γ given by the single</text>
<text top="321" left="81" width="359" height="12" font="3">rule p(x), r(x, y) → p(y) where r is an evidence predicate.</text>
<text top="337" left="81" width="359" height="12" font="3">Then, the problem of ﬁnding a minimum-cost balanced bi-</text>
<text top="353" left="81" width="359" height="12" font="3">section of the MRF that results from Γ is NP-hard in the</text>
<text top="368" left="81" width="162" height="12" font="3">size of the evidence (data).</text>
<text top="397" left="81" width="359" height="12" font="3">The proof (Appendix B.6) is by reduction to the graph min-</text>
<text top="413" left="81" width="359" height="12" font="3">imum bisection problem [14], which is hard to approximate</text>
<text top="429" left="81" width="359" height="12" font="3">(unless P = NP, there is no PTAS). In fact, the problem</text>
<text top="444" left="81" width="359" height="12" font="3">we are facing (multi-way hypergraph partitioning) is more</text>
<text top="460" left="81" width="359" height="12" font="3">challenging than graph bisection, and has been extensively</text>
<text top="476" left="81" width="359" height="12" font="3">studied [12, 24]. And so, we design a simple, greedy parti-</text>
<text top="492" left="81" width="359" height="12" font="3">tioning algorithm: it assigns each clause to a bin in descend-</text>
<text top="507" left="81" width="359" height="12" font="3">ing order by clause weight, subject to the constraint that no</text>
<text top="523" left="81" width="359" height="12" font="3">component in the resulting graph is larger than an input</text>
<text top="539" left="81" width="334" height="12" font="3">parameter β. We include pseudocode in Appendix B.7.</text>
<text top="571" left="81" width="156" height="14" font="5">Partition-aware Search.</text>
<text top="572" left="244" width="195" height="12" font="3">We need to reﬁne the search pro-</text>
<text top="588" left="81" width="359" height="12" font="3">cedure to be aware of partitions: the central challenge is</text>
<text top="604" left="81" width="359" height="12" font="3">that a clause in the cut may depend on atoms in two dis-</text>
<text top="619" left="81" width="359" height="12" font="3">tinct partitions. Hence, there are dependencies between the</text>
<text top="635" left="81" width="359" height="12" font="3">partitions. We exploit the idea in Example 2 to design the</text>
<text top="651" left="81" width="359" height="12" font="3">following partition-aware search scheme – which is an in-</text>
<text top="666" left="81" width="359" height="12" font="3">stance of the Gauss-Seidel method from nonlinear optimiza-</text>
<text top="682" left="81" width="177" height="12" font="3">tion [3, pg. 219]. Denote by X</text>
<text top="687" left="258" width="5" height="8" font="1">1</text>
<text top="682" left="264" width="42" height="12" font="3">, . . . , X</text>
<text top="687" left="306" width="6" height="8" font="1">k</text>
<text top="682" left="316" width="123" height="12" font="3">the states (i.e., truth</text>
<text top="698" left="81" width="359" height="12" font="3">assignments to the atoms) of the partitions. First initialize</text>
<text top="713" left="81" width="11" height="12" font="3">X</text>
<text top="718" left="92" width="4" height="8" font="1">i</text>
<text top="713" left="102" width="23" height="12" font="3">= x</text>
<text top="711" left="125" width="5" height="8" font="1">0</text>
<text top="719" left="125" width="4" height="8" font="1">i</text>
<text top="713" left="136" width="303" height="12" font="3">for i = 1 . . . k. For t = 1 . . . T , for i = 1 . . . k, run</text>
<text top="729" left="81" width="88" height="12" font="3">WalkSAT on x</text>
<text top="726" left="169" width="18" height="8" font="1">t−1</text>
<text top="736" left="169" width="4" height="8" font="1">i</text>
<text top="729" left="192" width="107" height="12" font="3">conditioned on {x</text>
<text top="727" left="299" width="4" height="8" font="1">t</text>
<text top="735" left="299" width="5" height="8" font="1">j</text>
<text top="728" left="304" width="93" height="13" font="3">|1 ≤ j &lt; i} ∪ {x</text>
<text top="726" left="397" width="18" height="8" font="1">t−1</text>
<text top="736" left="397" width="5" height="8" font="1">j</text>
<text top="728" left="416" width="23" height="13" font="3">|i &lt;</text>
<text top="748" left="81" width="112" height="12" font="3">j ≤ k} to obtain x</text>
<text top="745" left="192" width="4" height="8" font="1">t</text>
<text top="753" left="192" width="4" height="8" font="1">i</text>
<text top="748" left="197" width="117" height="12" font="3">. Finally, return {x</text>
<text top="745" left="314" width="7" height="8" font="1">T</text>
<text top="753" left="314" width="4" height="8" font="1">i</text>
<text top="747" left="323" width="71" height="13" font="3">|1 ≤ i ≤ k}.</text>
<text top="780" left="81" width="66" height="14" font="5">Tradeoffs.</text>
<text top="781" left="154" width="289" height="12" font="3">Although ﬁne-grained partitioning improves per-</text>
<text top="797" left="81" width="359" height="12" font="3">partition search speed (Theorem 3.1) and space eﬃciency, it</text>
<text top="813" left="81" width="359" height="12" font="3">also increases cut sizes – especially for dense graphs – which</text>
<text top="828" left="81" width="359" height="12" font="3">would in turn slow down the Gauss-Seidel inference scheme.</text>
<text top="844" left="81" width="359" height="12" font="3">Thus, there is an interesting tradeoﬀ of partitioning gran-</text>
<text top="860" left="81" width="359" height="12" font="3">ularity. In Section B.8, we describe a basic heuristic that</text>
<text top="876" left="81" width="318" height="12" font="3">combines Theorem 3.1 and the Gauss-Seidel scheme.</text>
<text top="908" left="81" width="13" height="16" font="2">4.</text>
<text top="908" left="112" width="132" height="16" font="2">EXPERIMENTS</text>
<text top="931" left="94" width="345" height="14" font="3">In this section, we validate ﬁrst that our system Tuffy is</text>
<text top="946" left="81" width="359" height="12" font="3">orders of magnitude more scalable and eﬃcient than prior</text>
<text top="962" left="81" width="359" height="12" font="3">approaches. We then validate that each of our techniques</text>
<text top="978" left="81" width="141" height="12" font="3">contributes to the goal.</text>
<text top="1002" left="81" width="136" height="14" font="5">Experimental Setup.</text>
<text top="1004" left="224" width="216" height="14" font="3">We select Alchemy, the currently</text>
<text top="1020" left="81" width="359" height="14" font="3">most widely used MLN system, as our comparison point.</text>
<text top="1038" left="81" width="359" height="12" font="3">Alchemy and Tuffy are implemented in C++ and Java,</text>
<text top="1051" left="81" width="359" height="14" font="3">respectively. The RDBMS used by Tuffy is PostgreSQL</text>
<text top="1067" left="81" width="359" height="12" font="3">8.4. Unless speciﬁed otherwise, all experiments are run on an</text>
<text top="135" left="661" width="32" height="10" font="8"><b>1.0E+03</b></text>
<text top="111" left="661" width="32" height="10" font="8"><b>2.0E+03</b></text>
<text top="87" left="661" width="32" height="10" font="8"><b>3.0E+03</b></text>
<text top="147" left="699" width="5" height="10" font="8"><b>0</b></text>
<text top="147" left="742" width="10" height="10" font="8"><b>20</b></text>
<text top="147" left="787" width="10" height="10" font="8"><b>40</b></text>
<text top="116" left="656" width="0" height="11" font="9"><b>co</b></text>
<text top="106" left="656" width="0" height="11" font="9"><b>st</b></text>
<text top="98" left="656" width="0" height="11" font="9"><b> </b></text>
<text top="87" left="759" width="12" height="12" font="10"><b>IE </b></text>
<text top="98" left="769" width="45" height="12" font="11">Alchemy </text>
<text top="127" left="722" width="28" height="12" font="11">Tuffy </text>
<text top="135" left="494" width="32" height="10" font="8"><b>0.0E+00</b></text>
<text top="119" left="494" width="32" height="10" font="8"><b>1.0E+04</b></text>
<text top="103" left="494" width="32" height="10" font="8"><b>2.0E+04</b></text>
<text top="87" left="494" width="32" height="10" font="8"><b>3.0E+04</b></text>
<text top="147" left="532" width="5" height="10" font="8"><b>0</b></text>
<text top="147" left="583" width="10" height="10" font="8"><b>50</b></text>
<text top="147" left="633" width="15" height="10" font="8"><b>100</b></text>
<text top="117" left="490" width="0" height="11" font="9"><b>cos</b></text>
<text top="102" left="490" width="0" height="11" font="9"><b>t </b></text>
<text top="90" left="568" width="14" height="12" font="10"><b>LP </b></text>
<text top="105" left="595" width="45" height="12" font="11">Alchemy </text>
<text top="105" left="552" width="28" height="12" font="11">Tuffy </text>
<text top="210" left="660" width="32" height="10" font="8"><b>0.0E+00</b></text>
<text top="187" left="660" width="32" height="10" font="8"><b>1.0E+05</b></text>
<text top="163" left="660" width="32" height="10" font="8"><b>2.0E+05</b></text>
<text top="223" left="698" width="5" height="10" font="8"><b>0</b></text>
<text top="223" left="719" width="103" height="10" font="8"><b>2000 4000 6000 8000</b></text>
<text top="192" left="656" width="0" height="11" font="9"><b>cos</b></text>
<text top="178" left="656" width="0" height="11" font="9"><b>t </b></text>
<text top="162" left="756" width="15" height="12" font="10"><b>ER </b></text>
<text top="178" left="707" width="118" height="10" font="12">Alchemy grounding took 7 hr. </text>
<text top="189" left="743" width="28" height="12" font="11">Tuffy </text>
<text top="210" left="494" width="32" height="10" font="8"><b>0.0E+00</b></text>
<text top="195" left="494" width="32" height="10" font="8"><b>2.0E+03</b></text>
<text top="179" left="494" width="32" height="10" font="8"><b>4.0E+03</b></text>
<text top="163" left="494" width="32" height="10" font="8"><b>6.0E+03</b></text>
<text top="223" left="532" width="5" height="10" font="8"><b>0</b></text>
<text top="223" left="555" width="20" height="10" font="8"><b>2000</b></text>
<text top="223" left="586" width="20" height="10" font="8"><b>4000</b></text>
<text top="223" left="616" width="20" height="10" font="8"><b>6000</b></text>
<text top="192" left="490" width="0" height="11" font="9"><b>cos</b></text>
<text top="178" left="490" width="0" height="11" font="9"><b>t </b></text>
<text top="165" left="567" width="16" height="12" font="10"><b>RC </b></text>
<text top="178" left="599" width="45" height="12" font="11">Alchemy </text>
<text top="186" left="559" width="28" height="12" font="11">Tuffy </text>
<text top="252" left="475" width="359" height="12" font="3">Figure 3: Time-cost plots of Alchemy vs. Tuﬀy; the</text>
<text top="268" left="475" width="145" height="12" font="3">x axes are time (sec)</text>
<text top="299" left="475" width="359" height="12" font="3">Intel Core2 at 2.4GHz with 4 GB of RAM running Red Hat</text>
<text top="315" left="475" width="359" height="12" font="3">Enterprise Linux 5. For fair comparison, in all experiments</text>
<text top="333" left="475" width="311" height="12" font="3">Tuffy runs a single thread unless otherwise noted.</text>
<text top="363" left="475" width="62" height="14" font="5">Datasets.</text>
<text top="364" left="544" width="290" height="14" font="3">We run Alchemy and Tuffy on four datasets;</text>
<text top="380" left="475" width="359" height="14" font="3">three of them (including their MLNs) are taken directly</text>
<text top="396" left="475" width="359" height="14" font="3">from the Alchemy website [7]: Link Prediction (LP), given</text>
<text top="412" left="475" width="359" height="12" font="3">an administrative database of a CS department, the goal</text>
<text top="427" left="475" width="359" height="12" font="3">is to predict student-adviser relationships; Information Ex-</text>
<text top="443" left="475" width="359" height="12" font="3">traction (IE), given a set of Citeseer citations, the goal is</text>
<text top="459" left="475" width="359" height="12" font="3">to extract from them structured records; and Entity Resolu-</text>
<text top="474" left="475" width="359" height="12" font="3">tion (ER), which is to deduplicate citation records based on</text>
<text top="490" left="475" width="359" height="12" font="3">word similarity. These tasks have been extensively used in</text>
<text top="506" left="475" width="359" height="12" font="3">prior work. The last task, Relational Classiﬁcation (RC),</text>
<text top="521" left="475" width="359" height="12" font="3">performs classiﬁcation on the Cora dataset [15]; RC con-</text>
<text top="537" left="475" width="359" height="12" font="3">tains all the rules in Figure 1. Table 1 contains statistics</text>
<text top="553" left="475" width="94" height="12" font="3">about the data.</text>
<text top="582" left="634" width="19" height="11" font="4">LP</text>
<text top="582" left="689" width="15" height="11" font="4">IE</text>
<text top="582" left="734" width="21" height="11" font="4">RC</text>
<text top="582" left="777" width="21" height="11" font="4">ER</text>
<text top="596" left="512" width="58" height="11" font="4">#relations</text>
<text top="596" left="640" width="13" height="11" font="4">22</text>
<text top="596" left="691" width="13" height="11" font="4">18</text>
<text top="596" left="748" width="6" height="11" font="4">4</text>
<text top="596" left="785" width="13" height="11" font="4">10</text>
<text top="609" left="512" width="37" height="11" font="4">#rules</text>
<text top="609" left="640" width="13" height="11" font="4">94</text>
<text top="609" left="687" width="16" height="11" font="4">1K</text>
<text top="609" left="742" width="13" height="11" font="4">15</text>
<text top="609" left="771" width="26" height="11" font="4">3.8K</text>
<text top="623" left="512" width="51" height="11" font="4">#entities</text>
<text top="623" left="634" width="19" height="11" font="4">302</text>
<text top="623" left="678" width="26" height="11" font="4">2.6K</text>
<text top="623" left="732" width="23" height="11" font="4">51K</text>
<text top="623" left="778" width="19" height="11" font="4">510</text>
<text top="636" left="512" width="95" height="11" font="4">#evidence tuples</text>
<text top="636" left="634" width="19" height="11" font="4">731</text>
<text top="636" left="669" width="34" height="11" font="4">0.25M</text>
<text top="636" left="720" width="34" height="11" font="4">0.43M</text>
<text top="636" left="778" width="19" height="11" font="4">676</text>
<text top="650" left="512" width="79" height="11" font="4">#query atoms</text>
<text top="650" left="627" width="26" height="11" font="4">4.6K</text>
<text top="650" left="669" width="34" height="11" font="4">0.34M</text>
<text top="650" left="732" width="23" height="11" font="4">10K</text>
<text top="650" left="775" width="23" height="11" font="4">16K</text>
<text top="663" left="512" width="76" height="11" font="4">#components</text>
<text top="663" left="646" width="6" height="11" font="4">1</text>
<text top="663" left="678" width="25" height="11" font="4">5341</text>
<text top="663" left="736" width="19" height="11" font="4">489</text>
<text top="663" left="791" width="6" height="11" font="4">1</text>
<text top="692" left="563" width="183" height="12" font="3">Table 1: Dataset statistics</text>
<text top="722" left="475" width="22" height="16" font="2">4.1</text>
<text top="722" left="516" width="182" height="16" font="2">High-level Performance</text>
<text top="744" left="489" width="345" height="14" font="3">We empirically demonstrate that Tuffy with all the tech-</text>
<text top="760" left="475" width="359" height="12" font="3">niques we have described has faster grounding, higher search</text>
<text top="775" left="475" width="359" height="12" font="3">speed, lower memory usage, and in some cases produces</text>
<text top="791" left="475" width="359" height="12" font="3">much better solutions than a competitor main memory ap-</text>
<text top="807" left="475" width="359" height="14" font="3">proach, Alchemy. Recall that the name of the game is</text>
<text top="823" left="475" width="359" height="12" font="3">to produce low-cost solutions quickly. With this in mind,</text>
<text top="838" left="475" width="359" height="14" font="3">we run Tuffy and Alchemy on each dataset for 7500 sec-</text>
<text top="854" left="475" width="359" height="12" font="3">onds, and track the cost of the best solution found up to</text>
<text top="870" left="475" width="359" height="12" font="3">any moment; on datasets that have multiple components,</text>
<text top="885" left="475" width="359" height="12" font="3">namely IE and RC, we apply the partitioning strategy in</text>
<text top="901" left="475" width="359" height="14" font="3">Section 3.3 on Tuffy. As shown in Figure 3, Tuffy of-</text>
<text top="917" left="475" width="359" height="12" font="3">ten reaches a best solution within orders of magnitude less</text>
<text top="932" left="475" width="359" height="14" font="3">time than Alchemy; secondly, the result quality of Tuffy</text>
<text top="948" left="475" width="359" height="12" font="3">is at least as good as – sometimes substantially better (e.g.,</text>
<text top="964" left="475" width="359" height="14" font="3">on IE and RC) than – Alchemy. Here, we have zoomed</text>
<text top="979" left="475" width="359" height="12" font="3">the time axes into interesting areas. Since “solution cost”</text>
<text top="995" left="475" width="359" height="12" font="3">is undeﬁned during grounding, each curve begins only when</text>
<text top="1011" left="475" width="139" height="12" font="3">grounding is completed</text>
<text top="1008" left="614" width="5" height="8" font="1">6</text>
<text top="1011" left="620" width="214" height="12" font="3">. We analyze the experiment results</text>
<text top="1027" left="475" width="238" height="12" font="3">in more detail in the following sections.</text>
<text top="1051" left="476" width="5" height="8" font="1">6</text>
<text top="1053" left="482" width="352" height="12" font="3">The L-shaped curves indicate that search converges very</text>
<text top="1067" left="475" width="224" height="12" font="3">quickly compared to grounding time.</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="13" size="8" family="Times" color="#000000"/>
<text top="82" left="223" width="19" height="11" font="4">LP</text>
<text top="82" left="258" width="15" height="11" font="4">IE</text>
<text top="82" left="298" width="21" height="11" font="4">RC</text>
<text top="82" left="350" width="21" height="11" font="4">ER</text>
<text top="99" left="149" width="53" height="10" font="4">Alchemy</text>
<text top="96" left="229" width="13" height="11" font="4">48</text>
<text top="96" left="261" width="13" height="11" font="4">13</text>
<text top="96" left="290" width="29" height="11" font="4">3,913</text>
<text top="96" left="336" width="35" height="11" font="4">23,891</text>
<text top="113" left="157" width="37" height="10" font="4">Tuffy</text>
<text top="111" left="235" width="6" height="11" font="4">6</text>
<text top="111" left="261" width="13" height="11" font="4">13</text>
<text top="111" left="306" width="13" height="11" font="4">40</text>
<text top="111" left="352" width="19" height="11" font="4">106</text>
<text top="141" left="154" width="212" height="12" font="3">Table 2: Grounding time (sec)</text>
<text top="227" left="99" width="31" height="10" font="12">0.0E+00</text>
<text top="201" left="99" width="31" height="10" font="12">1.0E+04</text>
<text top="175" left="99" width="31" height="10" font="12">2.0E+04</text>
<text top="240" left="137" width="5" height="10" font="12">0</text>
<text top="240" left="172" width="20" height="10" font="12">1000</text>
<text top="240" left="215" width="20" height="10" font="12">2000</text>
<text top="200" left="94" width="0" height="11" font="9"><b>co</b></text>
<text top="190" left="94" width="0" height="11" font="9"><b>st</b></text>
<text top="182" left="94" width="0" height="11" font="9"><b> </b></text>
<text top="254" left="171" width="47" height="11" font="9"><b>time (sec) </b></text>
<text top="164" left="191" width="14" height="12" font="10"><b>LP </b></text>
<text top="192" left="175" width="70" height="11" font="13">Alchemy (solid) </text>
<text top="180" left="165" width="64" height="11" font="13">Tuffy-p (dash) </text>
<text top="205" left="201" width="46" height="11" font="13">Tuffy-mm </text>
<text top="227" left="268" width="31" height="10" font="12">0.0E+00</text>
<text top="198" left="268" width="31" height="10" font="12">2.0E+05</text>
<text top="168" left="268" width="31" height="10" font="12">4.0E+05</text>
<text top="240" left="306" width="5" height="10" font="12">0</text>
<text top="240" left="353" width="20" height="10" font="12">4000</text>
<text top="240" left="409" width="20" height="10" font="12">8000</text>
<text top="200" left="263" width="0" height="11" font="9"><b>co</b></text>
<text top="190" left="263" width="0" height="11" font="9"><b>st</b></text>
<text top="182" left="263" width="0" height="11" font="9"><b> </b></text>
<text top="254" left="341" width="47" height="11" font="9"><b>time (sec) </b></text>
<text top="167" left="360" width="16" height="12" font="10"><b>RC </b></text>
<text top="195" left="385" width="40" height="11" font="13">Alchemy </text>
<text top="216" left="323" width="34" height="11" font="13">Tuffy-p </text>
<text top="180" left="316" width="46" height="11" font="13">Tuffy-mm </text>
<text top="282" left="81" width="359" height="12" font="3">Figure 4: Time-cost plots of Alchemy vs. Tuﬀy-p</text>
<text top="297" left="81" width="359" height="12" font="3">(i.e., Tuﬀy without partitioning) vs. Tuﬀy-mm (i.e.,</text>
<text top="313" left="81" width="237" height="12" font="3">Tuﬀy with RDBMS-based search)</text>
<text top="351" left="81" width="22" height="16" font="2">4.2</text>
<text top="351" left="121" width="241" height="16" font="2">Effect of Bottom-up Grounding</text>
<text top="373" left="94" width="345" height="12" font="3">We validate that the RDBMS-based grounding approach</text>
<text top="389" left="81" width="359" height="14" font="3">in Tuffy allows us to complete the grounding process orders</text>
<text top="405" left="81" width="359" height="14" font="3">of magnitude more eﬃciently than Alchemy. To make this</text>
<text top="420" left="81" width="359" height="14" font="3">point, we run Tuffy and Alchemy on the four datasets,</text>
<text top="436" left="81" width="359" height="12" font="3">and show their grounding time in Table 2. We can see that</text>
<text top="454" left="81" width="359" height="12" font="3">Tuffy outperforms Alchemy by orders of magnitude at</text>
<text top="467" left="81" width="359" height="12" font="3">run time in the grounding phase (a factor of 225 on the</text>
<text top="483" left="81" width="359" height="12" font="3">ER dataset). To understand the diﬀerences, we dug deeper</text>
<text top="499" left="81" width="359" height="12" font="3">with a lesion study (i.e., disabling one aspect of a system at</text>
<text top="514" left="81" width="359" height="12" font="3">a time), and found that sort join and hash join algorithms</text>
<text top="530" left="81" width="359" height="12" font="3">(along with predicate pushdown) are the key components of</text>
<text top="546" left="81" width="359" height="14" font="3">the RDBMS that speeds up the grounding process of Tuffy</text>
<text top="561" left="81" width="359" height="14" font="3">(Appendix C.2). Tuffy obviates the need for Alchemy to</text>
<text top="577" left="81" width="342" height="12" font="3">reimplement the optimization techniques in an RDBMS.</text>
<text top="605" left="81" width="22" height="16" font="2">4.3</text>
<text top="605" left="121" width="227" height="16" font="2">Effect of Hybrid Architecture</text>
<text top="627" left="94" width="345" height="12" font="3">We validate two technical claims: (1) the hybrid memory</text>
<text top="643" left="81" width="359" height="14" font="3">management strategy of Tuffy (even without our parti-</text>
<text top="659" left="81" width="359" height="12" font="3">tioning optimizations) has comparable search rates to exist-</text>
<text top="674" left="81" width="359" height="12" font="3">ing main memory implementations (and much faster than</text>
<text top="690" left="81" width="359" height="14" font="3">RDBMS-based implementation) and (2) Tuffy maintains</text>
<text top="706" left="81" width="359" height="12" font="3">a much smaller memory footprint (again without partition-</text>
<text top="721" left="81" width="359" height="14" font="3">ing). Thus, we compare three approaches: (1) Tuffy with-</text>
<text top="737" left="81" width="359" height="14" font="3">out the partitioning optimizations, called Tuffy-p (read:</text>
<text top="753" left="81" width="359" height="14" font="3">Tuﬀy minus p), (2) a version of Tuffy (also without parti-</text>
<text top="768" left="81" width="359" height="12" font="3">tioning) that implements RDBMS-based WalkSAT (detailed</text>
<text top="784" left="81" width="305" height="14" font="3">in Appendix B.2), Tuffy-mm, and (3) Alchemy.</text>
<text top="800" left="94" width="345" height="12" font="3">Figure 4 illustrates the time-cost plots on LP and RC of</text>
<text top="816" left="81" width="359" height="14" font="3">all three approaches. We see from RC that Tuffy-p is able</text>
<text top="831" left="81" width="359" height="14" font="3">to ground much more quickly than Alchemy (40 sec com-</text>
<text top="847" left="81" width="359" height="12" font="3">pared to 3913 sec). Additionally, we see that, compared to</text>
<text top="865" left="81" width="359" height="12" font="3">Tuffy-mm, Tuffy-p’s in-memory search is orders of mag-</text>
<text top="878" left="81" width="359" height="12" font="3">nitude faster at getting to their best reported solution (both</text>
<text top="894" left="81" width="359" height="12" font="3">approaches ﬁnish grounding at the same time, and so start</text>
<text top="910" left="81" width="359" height="12" font="3">search at the same time). To understand why, we measure</text>
<text top="925" left="81" width="359" height="12" font="3">the ﬂipping rate, which is the number of steps performed by</text>
<text top="941" left="81" width="359" height="12" font="3">WalkSAT per second. As shown in Table 3, the reason is</text>
<text top="957" left="81" width="359" height="14" font="3">that Tuffy-mm has a dramatically lower ﬂipping rate. We</text>
<text top="972" left="81" width="359" height="12" font="3">discuss the performance bound of any RDBMS-based search</text>
<text top="988" left="81" width="203" height="12" font="3">implementation in Appendix C.1.</text>
<text top="1004" left="94" width="345" height="14" font="3">To validate our second claim, that Tuffy-p has a smaller</text>
<text top="1020" left="81" width="359" height="12" font="3">memory footprint, we see in Table 4, that on all datasets,</text>
<text top="1035" left="81" width="359" height="14" font="3">the memory footprint of Tuffy is no more than 5% of</text>
<text top="1053" left="81" width="359" height="12" font="3">Alchemy. Drilling down, the reason is that the interme-</text>
<text top="1067" left="81" width="359" height="14" font="3">diate state size of Alchemy’s grounding process may be</text>
<text top="82" left="622" width="19" height="11" font="4">LP</text>
<text top="82" left="676" width="15" height="11" font="4">IE</text>
<text top="82" left="721" width="21" height="11" font="4">RC</text>
<text top="82" left="761" width="21" height="11" font="4">ER</text>
<text top="99" left="528" width="53" height="10" font="4">Alchemy</text>
<text top="96" left="606" width="34" height="11" font="4">0.20M</text>
<text top="96" left="674" width="18" height="11" font="4">1M</text>
<text top="96" left="716" width="26" height="11" font="4">1.9K</text>
<text top="96" left="759" width="26" height="11" font="4">0.9K</text>
<text top="113" left="524" width="63" height="10" font="4">Tuffy-mm</text>
<text top="111" left="624" width="16" height="11" font="4">0.9</text>
<text top="111" left="679" width="13" height="11" font="4">13</text>
<text top="111" left="726" width="16" height="11" font="4">0.9</text>
<text top="111" left="763" width="23" height="11" font="4">0.03</text>
<text top="127" left="531" width="48" height="10" font="4">Tuffy-p</text>
<text top="125" left="606" width="34" height="11" font="4">0.11M</text>
<text top="125" left="657" width="34" height="11" font="4">0.39M</text>
<text top="125" left="708" width="34" height="11" font="4">0.17M</text>
<text top="125" left="759" width="26" height="11" font="4">7.9K</text>
<text top="155" left="531" width="248" height="12" font="3">Table 3: Flipping rates (#ﬂips/sec)</text>
<text top="171" left="622" width="19" height="11" font="4">LP</text>
<text top="171" left="687" width="15" height="11" font="4">IE</text>
<text top="171" left="738" width="21" height="11" font="4">RC</text>
<text top="171" left="800" width="21" height="11" font="4">ER</text>
<text top="185" left="501" width="65" height="11" font="4">clause table</text>
<text top="185" left="600" width="41" height="11" font="4">5.2 MB</text>
<text top="185" left="661" width="41" height="11" font="4">0.6 MB</text>
<text top="185" left="718" width="41" height="11" font="4">4.8 MB</text>
<text top="185" left="776" width="44" height="11" font="4">164 MB</text>
<text top="201" left="489" width="88" height="10" font="4">Alchemy RAM</text>
<text top="199" left="597" width="44" height="11" font="4">411 MB</text>
<text top="199" left="658" width="44" height="11" font="4">206 MB</text>
<text top="199" left="720" width="39" height="11" font="4">2.8 GB</text>
<text top="199" left="781" width="39" height="11" font="4">3.5 GB</text>
<text top="216" left="491" width="83" height="10" font="4">Tuffy-p RAM</text>
<text top="213" left="610" width="31" height="11" font="4">9 MB</text>
<text top="213" left="670" width="31" height="11" font="4">8 MB</text>
<text top="213" left="722" width="38" height="11" font="4">19 MB</text>
<text top="213" left="776" width="44" height="11" font="4">184 MB</text>
<text top="243" left="475" width="295" height="12" font="3">Table 4: Space eﬃciency of Alchemy vs.</text>
<text top="243" left="783" width="51" height="12" font="3">Tuﬀy-p</text>
<text top="258" left="475" width="154" height="12" font="3">(without partitioning)</text>
<text top="289" left="475" width="359" height="12" font="3">larger than the size of grounding results. For example, on</text>
<text top="305" left="475" width="359" height="14" font="3">the RC dataset, Alchemy allocated 2.8 GB of RAM only to</text>
<text top="321" left="475" width="359" height="14" font="3">produce 4.8 MB of ground clauses. While Alchemy has to</text>
<text top="336" left="475" width="359" height="14" font="3">hold everything in memory, Tuffy only needs to load the</text>
<text top="352" left="475" width="359" height="12" font="3">grounding result from the RDBMS at the end of grounding.</text>
<text top="368" left="475" width="359" height="14" font="3">It follows that, given the same resources, there are MLNs</text>
<text top="384" left="475" width="359" height="14" font="3">that Tuffy can handle eﬃciently while Alchemy would</text>
<text top="399" left="475" width="359" height="12" font="3">crash. Indeed, on a dataset called “ER+” which is twice</text>
<text top="415" left="475" width="359" height="14" font="3">as large as ER, Alchemy exhausts all 4GB of RAM and</text>
<text top="431" left="475" width="359" height="14" font="3">crashes soon after launching, whereas Tuffy runs normally</text>
<text top="446" left="475" width="238" height="12" font="3">with peak RAM usage of roughly 2GB.</text>
<text top="462" left="489" width="345" height="12" font="3">From these experiments, we conclude that the hybrid ar-</text>
<text top="478" left="475" width="297" height="14" font="3">chitecture is crucial to Tuffy’s overall eﬃciency.</text>
<text top="503" left="475" width="22" height="16" font="2">4.4</text>
<text top="503" left="516" width="162" height="16" font="2">Effect of Partitioning</text>
<text top="525" left="489" width="345" height="12" font="3">In this section, we validate that, when there are multi-</text>
<text top="541" left="475" width="359" height="12" font="3">ple components in the data, partitioning not only improves</text>
<text top="559" left="475" width="359" height="12" font="3">Tuffy’s space eﬃciency, but – due to Theorem 3.1 – may</text>
<text top="572" left="475" width="359" height="14" font="3">actually enable Tuffy to ﬁnd substantially higher quality</text>
<text top="588" left="475" width="359" height="14" font="3">results. We compare Tuffy’s performance (with partition-</text>
<text top="604" left="475" width="359" height="14" font="3">ing enabled) against Tuffy-p: a version of Tuffy with</text>
<text top="620" left="475" width="129" height="12" font="3">partitioning disabled.</text>
<text top="635" left="489" width="345" height="12" font="3">We run the search phase on each of the four datasets using</text>
<text top="651" left="475" width="359" height="14" font="3">three approaches: Alchemy, Tuffy-p, and Tuffy (with</text>
<text top="667" left="475" width="359" height="14" font="3">partitioning). Tuffy-p and Alchemy run WalkSAT on the</text>
<text top="682" left="475" width="114" height="12" font="3">whole MRF for 10</text>
<text top="680" left="589" width="5" height="8" font="1">7</text>
<text top="682" left="601" width="233" height="14" font="3">steps. Tuffy runs WalkSAT on each</text>
<text top="698" left="475" width="354" height="12" font="3">component in the MRF independently, each component G</text>
<text top="703" left="829" width="4" height="8" font="1">i</text>
<text top="714" left="475" width="71" height="12" font="3">receiving 10</text>
<text top="711" left="546" width="5" height="8" font="1">7</text>
<text top="713" left="552" width="15" height="13" font="3">|G</text>
<text top="718" left="567" width="4" height="8" font="1">i</text>
<text top="713" left="572" width="125" height="13" font="3">|/|G| steps, where |G</text>
<text top="718" left="697" width="4" height="8" font="1">i</text>
<text top="713" left="701" width="132" height="13" font="3">| and |G| are the num-</text>
<text top="729" left="475" width="359" height="12" font="3">bers of atoms in this component and the MRF, respectively.</text>
<text top="745" left="475" width="246" height="12" font="3">This is weighted round-robin scheduling.</text>
<text top="776" left="626" width="19" height="11" font="4">LP</text>
<text top="776" left="673" width="15" height="11" font="4">IE</text>
<text top="776" left="717" width="21" height="11" font="4">RC</text>
<text top="776" left="774" width="21" height="11" font="4">ER</text>
<text top="790" left="518" width="76" height="11" font="4">#components</text>
<text top="790" left="638" width="6" height="11" font="4">1</text>
<text top="790" left="663" width="25" height="11" font="4">5341</text>
<text top="790" left="719" width="19" height="11" font="4">489</text>
<text top="790" left="788" width="6" height="11" font="4">1</text>
<text top="806" left="514" width="83" height="10" font="4">Tuffy-p RAM</text>
<text top="804" left="618" width="27" height="11" font="4">9MB</text>
<text top="804" left="661" width="27" height="11" font="4">8MB</text>
<text top="804" left="705" width="33" height="11" font="4">19MB</text>
<text top="804" left="755" width="40" height="11" font="4">184MB</text>
<text top="820" left="520" width="72" height="10" font="4">Tuffy RAM</text>
<text top="818" left="618" width="27" height="11" font="4">9MB</text>
<text top="818" left="661" width="27" height="11" font="4">8MB</text>
<text top="818" left="705" width="33" height="11" font="4">15MB</text>
<text top="818" left="755" width="40" height="11" font="4">184MB</text>
<text top="834" left="519" width="75" height="10" font="4">Tuffy-p cost</text>
<text top="832" left="619" width="25" height="11" font="4">2534</text>
<text top="832" left="663" width="25" height="11" font="4">1933</text>
<text top="832" left="713" width="25" height="11" font="4">1943</text>
<text top="832" left="763" width="32" height="11" font="4">18717</text>
<text top="848" left="524" width="63" height="10" font="4">Tuffy cost</text>
<text top="846" left="619" width="25" height="11" font="4">2534</text>
<text top="846" left="663" width="25" height="11" font="4">1635</text>
<text top="846" left="713" width="25" height="11" font="4">1281</text>
<text top="846" left="763" width="32" height="11" font="4">18717</text>
<text top="876" left="475" width="59" height="12" font="3">Table 5:</text>
<text top="876" left="546" width="182" height="12" font="3">Performance of Tuﬀy vs.</text>
<text top="876" left="744" width="90" height="12" font="3">Tuﬀy-p (i.e.,</text>
<text top="892" left="475" width="190" height="12" font="3">Tuﬀy without partitioning)</text>
<text top="925" left="489" width="345" height="12" font="3">As shown in Table 5, when there are multiple compo-</text>
<text top="941" left="475" width="359" height="14" font="3">nents in the MRF, partitioning allows Tuffy to use less</text>
<text top="957" left="475" width="359" height="14" font="3">memory than Tuffy-p. (The IE dataset is too small to</text>
<text top="972" left="475" width="359" height="14" font="3">yield notable diﬀerences). We see that Tuffy’s component-</text>
<text top="988" left="475" width="359" height="12" font="3">aware inference can produce signiﬁcantly better results than</text>
<text top="1006" left="475" width="359" height="12" font="3">Tuffy-p. We then extend the run time of all systems. As</text>
<text top="1020" left="475" width="359" height="12" font="3">shown in Figure 5, there continues to be a gap between</text>
<text top="1038" left="475" width="359" height="12" font="3">Tuffy’s component-aware search approach and the original</text>
<text top="1051" left="475" width="359" height="12" font="3">WalkSAT running on the whole MRF. This gap is predicted</text>
<text top="1067" left="475" width="359" height="12" font="3">by our theoretical analysis in Section 3.3. Thus, we have</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="14" size="12" family="Times" color="#000000"/>
<text top="143" left="100" width="20" height="10" font="12">1000</text>
<text top="126" left="100" width="20" height="10" font="12">1400</text>
<text top="110" left="100" width="20" height="10" font="12">1800</text>
<text top="94" left="100" width="20" height="10" font="12">2200</text>
<text top="78" left="100" width="20" height="10" font="12">2600</text>
<text top="155" left="126" width="5" height="10" font="12">0</text>
<text top="155" left="156" width="10" height="10" font="12">20</text>
<text top="155" left="189" width="10" height="10" font="12">40</text>
<text top="155" left="222" width="10" height="10" font="12">60</text>
<text top="155" left="254" width="10" height="10" font="12">80</text>
<text top="116" left="95" width="0" height="11" font="9"><b>co</b></text>
<text top="105" left="95" width="0" height="11" font="9"><b>st</b></text>
<text top="97" left="95" width="0" height="11" font="9"><b> </b></text>
<text top="169" left="172" width="47" height="11" font="9"><b>time (sec) </b></text>
<text top="77" left="201" width="14" height="14" font="14"><b>IE </b></text>
<text top="135" left="204" width="22" height="10" font="12">Tuffy </text>
<text top="84" left="132" width="64" height="10" font="12">Tuffy-p (dotted) </text>
<text top="96" left="132" width="62" height="10" font="12">Alchemy (solid) </text>
<text top="143" left="280" width="5" height="10" font="12">0</text>
<text top="121" left="266" width="20" height="10" font="12">1000</text>
<text top="99" left="266" width="20" height="10" font="12">2000</text>
<text top="78" left="266" width="20" height="10" font="12">3000</text>
<text top="155" left="292" width="5" height="10" font="12">0</text>
<text top="155" left="328" width="15" height="10" font="12">100</text>
<text top="155" left="369" width="15" height="10" font="12">200</text>
<text top="155" left="410" width="15" height="10" font="12">300</text>
<text top="116" left="261" width="0" height="11" font="9"><b>cos</b></text>
<text top="101" left="261" width="0" height="11" font="9"><b>t </b></text>
<text top="169" left="334" width="47" height="11" font="9"><b>time (sec) </b></text>
<text top="77" left="336" width="19" height="14" font="14"><b>RC </b></text>
<text top="106" left="363" width="22" height="10" font="12">Tuffy </text>
<text top="83" left="370" width="30" height="10" font="12">Tuffy-p </text>
<text top="135" left="304" width="121" height="8" font="1">Alchemy grounding took over 1 hr. </text>
<text top="195" left="81" width="359" height="12" font="3">Figure 5: Time-cost plots of Tuﬀy vs Tuﬀy-p (i.e.,</text>
<text top="211" left="81" width="190" height="12" font="3">Tuﬀy without partitioning)</text>
<text top="304" left="98" width="17" height="9" font="1">0E+0</text>
<text top="280" left="98" width="17" height="9" font="1">1E+3</text>
<text top="256" left="98" width="17" height="9" font="1">2E+3</text>
<text top="232" left="98" width="17" height="9" font="1">3E+3</text>
<text top="315" left="121" width="4" height="9" font="1">0</text>
<text top="315" left="139" width="13" height="9" font="1">100</text>
<text top="315" left="161" width="13" height="9" font="1">200</text>
<text top="315" left="184" width="13" height="9" font="1">300</text>
<text top="273" left="94" width="0" height="10" font="8"><b>cos</b></text>
<text top="260" left="94" width="0" height="10" font="8"><b>t </b></text>
<text top="327" left="137" width="42" height="10" font="8"><b>time (sec) </b></text>
<text top="233" left="154" width="13" height="10" font="8"><b>RC </b></text>
<text top="243" left="173" width="23" height="10" font="12">15MB</text>
<text top="254" left="173" width="23" height="10" font="12">13MB</text>
<text top="266" left="173" width="23" height="10" font="12">12MB</text>
<text top="304" left="210" width="24" height="9" font="1">2.4E+3</text>
<text top="280" left="210" width="24" height="9" font="1">2.6E+3</text>
<text top="256" left="210" width="24" height="9" font="1">2.8E+3</text>
<text top="232" left="210" width="24" height="9" font="1">3.0E+3</text>
<text top="315" left="240" width="4" height="9" font="1">0</text>
<text top="315" left="259" width="9" height="9" font="1">50</text>
<text top="315" left="277" width="34" height="9" font="1">100 150</text>
<text top="273" left="206" width="0" height="10" font="8"><b>cos</b></text>
<text top="260" left="206" width="0" height="10" font="8"><b>t </b></text>
<text top="327" left="254" width="42" height="10" font="8"><b>time (sec) </b></text>
<text top="234" left="264" width="13" height="11" font="9"><b>LP </b></text>
<text top="249" left="286" width="18" height="10" font="12">9MB</text>
<text top="260" left="286" width="18" height="10" font="12">5MB</text>
<text top="271" left="286" width="26" height="10" font="12">3.5MB</text>
<text top="304" left="326" width="17" height="9" font="1">0E+0</text>
<text top="286" left="326" width="17" height="9" font="1">2E+4</text>
<text top="268" left="326" width="17" height="9" font="1">4E+4</text>
<text top="250" left="326" width="17" height="9" font="1">6E+4</text>
<text top="232" left="326" width="17" height="9" font="1">8E+4</text>
<text top="315" left="349" width="4" height="9" font="1">0</text>
<text top="315" left="367" width="59" height="9" font="1">500 1000 1500</text>
<text top="273" left="322" width="0" height="10" font="8"><b>cos</b></text>
<text top="260" left="322" width="0" height="10" font="8"><b>t </b></text>
<text top="327" left="364" width="42" height="10" font="8"><b>time (sec) </b></text>
<text top="234" left="379" width="14" height="11" font="9"><b>ER </b></text>
<text top="247" left="399" width="28" height="10" font="12">200MB</text>
<text top="260" left="399" width="28" height="10" font="12">100MB</text>
<text top="272" left="399" width="23" height="10" font="12">50MB</text>
<text top="352" left="81" width="65" height="12" font="3">Figure 6:</text>
<text top="352" left="158" width="281" height="12" font="3">Time-cost plots of Tuﬀy with diﬀerent</text>
<text top="368" left="81" width="116" height="12" font="3">memory budgets</text>
<text top="392" left="81" width="359" height="14" font="3">veriﬁed that partitioning makes Tuffy substantially more</text>
<text top="408" left="81" width="297" height="12" font="3">eﬃcient in terms of both space and search speed.</text>
<text top="423" left="94" width="345" height="14" font="3">We also validate that Tuffy’s loading and parallelism</text>
<text top="439" left="81" width="359" height="12" font="3">makes a substantial diﬀerence: without our batch loading</text>
<text top="455" left="81" width="272" height="14" font="3">technique, Tuffy takes 448s to perform 10</text>
<text top="452" left="353" width="5" height="8" font="1">6</text>
<text top="455" left="366" width="74" height="12" font="3">search steps</text>
<text top="470" left="81" width="359" height="12" font="3">per component on RC, while 117s to perform the same op-</text>
<text top="486" left="81" width="359" height="12" font="3">eration with batch loading. With the addition of 8 threads</text>
<text top="502" left="81" width="359" height="12" font="3">(on 8 cores), we further reduce the runtime to 28s. Addi-</text>
<text top="517" left="81" width="359" height="12" font="3">tional loading and parallelism experiments in Appendix C.3</text>
<text top="533" left="81" width="359" height="12" font="3">support our claim that our loading algorithm and partition-</text>
<text top="549" left="81" width="339" height="12" font="3">ing algorithm contribute to improving processing speed.</text>
<text top="573" left="81" width="22" height="16" font="2">4.5</text>
<text top="573" left="121" width="227" height="16" font="2">Effect of Further Partitioning</text>
<text top="596" left="94" width="345" height="12" font="3">To validate our claim that splitting MRF components can</text>
<text top="611" left="81" width="359" height="12" font="3">further improve both space eﬃciency and sometimes also</text>
<text top="627" left="81" width="359" height="14" font="3">search quality (Section 3.4), we run Tuffy on RC, ER, and</text>
<text top="643" left="81" width="359" height="12" font="3">LP with diﬀerent memory budgets – which are fed to the</text>
<text top="658" left="81" width="359" height="12" font="3">partitioning algorithm as the bound of partition size. On</text>
<text top="674" left="81" width="359" height="14" font="3">each dataset, we give Tuffy three memory budgets, with</text>
<text top="690" left="81" width="359" height="12" font="3">the largest one corresponding to the case when no compo-</text>
<text top="706" left="81" width="359" height="12" font="3">nents are split. Figure 6 shows the experiment results. On</text>
<text top="721" left="81" width="359" height="12" font="3">RC, we see another improvement of the result quality (cf.</text>
<text top="737" left="81" width="359" height="12" font="3">Figure 5). Similar to Example 2, we believe the reason to be</text>
<text top="753" left="81" width="359" height="12" font="3">graph sparsity: “13MB” cuts only about 420 out of the to-</text>
<text top="768" left="81" width="359" height="12" font="3">tal 10K clauses. In contrast, while MRF partitioning lowers</text>
<text top="784" left="81" width="359" height="12" font="3">RAM usage considerably on ER, it also leads to slower con-</text>
<text top="800" left="81" width="359" height="12" font="3">vergence – which correlates with poor partitioning quality:</text>
<text top="815" left="81" width="359" height="12" font="3">the MRF of ER is quite dense and even 2-way partition-</text>
<text top="831" left="81" width="359" height="12" font="3">ing (“100MB”) would cut over 1.4M out of the total 2M</text>
<text top="847" left="81" width="359" height="12" font="3">clauses. The dataset LP illustrates the interesting tradeoﬀ</text>
<text top="862" left="81" width="359" height="12" font="3">where a coarse partition is beneﬁcial whereas ﬁner grained</text>
<text top="878" left="81" width="359" height="12" font="3">partitions would be detrimental. We discuss this tradeoﬀ in</text>
<text top="894" left="81" width="88" height="12" font="3">Appendix B.8.</text>
<text top="919" left="81" width="13" height="16" font="2">5.</text>
<text top="919" left="112" width="122" height="16" font="2">CONCLUSION</text>
<text top="941" left="94" width="345" height="12" font="3">Motivated by a large set of data-rich applications, we</text>
<text top="957" left="81" width="359" height="14" font="3">study how to push MLN inference inside an RDBMS. We</text>
<text top="972" left="81" width="359" height="14" font="3">ﬁnd that the grounding phase of MLN inference performs</text>
<text top="988" left="81" width="359" height="12" font="3">many relational operations and that these operations are a</text>
<text top="1004" left="81" width="359" height="14" font="3">substantial bottleneck in state-of-the-art MLN implementa-</text>
<text top="1020" left="81" width="359" height="14" font="3">tions such as Alchemy. Using an RDBMS, Tuffy not only</text>
<text top="1035" left="81" width="359" height="12" font="3">achieves scalability, but also speeds up the grounding phase</text>
<text top="1051" left="81" width="359" height="12" font="3">by orders of magnitude. We then develop a hybrid solution</text>
<text top="1067" left="81" width="359" height="12" font="3">with RDBMS-based grounding and in-memory search. To</text>
<text top="86" left="475" width="359" height="14" font="3">improve the space and time eﬃciency of Tuffy, we study a</text>
<text top="102" left="475" width="359" height="12" font="3">partitioning approach that allows for in-memory search even</text>
<text top="118" left="475" width="359" height="12" font="3">when the dataset does not ﬁt in memory. We showed that</text>
<text top="133" left="475" width="359" height="14" font="3">further partitioning allows Tuffy to produce higher quality</text>
<text top="149" left="475" width="215" height="12" font="3">results in a shorter amount of time.</text>
<text top="171" left="475" width="13" height="16" font="2">6.</text>
<text top="171" left="507" width="121" height="16" font="2">REFERENCES</text>
<text top="188" left="481" width="321" height="9" font="13">[1] L. Antova, T. Jansen, C. Koch, and D. Olteanu. Fast and</text>
<text top="200" left="501" width="326" height="9" font="13">simple relational processing of uncertain data. In ICDE, 2008.</text>
<text top="213" left="481" width="308" height="9" font="13">[2] O. Benjelloun, A. Sarma, A. Halevy, M. Theobald, and</text>
<text top="225" left="501" width="326" height="9" font="13">J. Widom. Databases with uncertainty and lineage. In VLDB,</text>
<text top="237" left="501" width="109" height="9" font="13">pages 243–264, 2008.</text>
<text top="251" left="481" width="341" height="9" font="13">[3] D. P. Bertsekas and J. N. Tsitsiklis. Parallel and Distributed</text>
<text top="263" left="501" width="294" height="9" font="13">Computation: Numerical Methods. Prentice-Hall, 1989.</text>
<text top="276" left="481" width="310" height="9" font="13">[4] N. N. Dalvi and D. Suciu. Eﬃcient query evaluation on</text>
<text top="288" left="501" width="292" height="9" font="13">probabilistic databases. In VLDB, pages 864–875, 2004.</text>
<text top="302" left="481" width="300" height="9" font="13">[5] A. Deshpande and S. Madden. MauveDB: Supporting</text>
<text top="313" left="501" width="307" height="9" font="13">model-based user views in database systems. In SIGMOD,</text>
<text top="325" left="501" width="97" height="9" font="13">pages 73–84, 2006.</text>
<text top="339" left="481" width="349" height="9" font="13">[6] P. Domingos and D. Lowd. Markov Logic: An Interface Layer</text>
<text top="351" left="501" width="266" height="9" font="13">for Artiﬁcial Intelligence. Morgan Claypool, 2009.</text>
<text top="364" left="481" width="307" height="10" font="13">[7] P. Domingos et al. http://alchemy.cs.washington.edu/.</text>
<text top="378" left="481" width="350" height="9" font="13">[8] R. Fagin, J. Y. Halpern, and N. Megiddo. A logic for reasoning</text>
<text top="390" left="501" width="304" height="9" font="13">about probabilities. Information and Computation, 1990.</text>
<text top="403" left="481" width="322" height="9" font="13">[9] W. Feller. An Introduction to Probability Theory and its</text>
<text top="415" left="501" width="248" height="9" font="13">Applications. Vol. I. John Wiley &amp; Sons, 1950.</text>
<text top="429" left="475" width="348" height="9" font="13">[10] R. Jampani, F. Xu, M. Wu, L. L. Perez, C. M. Jermaine, and</text>
<text top="441" left="501" width="299" height="9" font="13">P. J. Haas. MCDB: A monte carlo approach to managing</text>
<text top="452" left="501" width="266" height="9" font="13">uncertain data. In SIGMOD, pages 687–700, 2008.</text>
<text top="466" left="475" width="356" height="9" font="13">[11] B. Kanagal and A. Deshpande. Online ﬁltering, smoothing and</text>
<text top="478" left="501" width="300" height="9" font="13">probabilistic modeling of streaming data. In ICDE, 2008.</text>
<text top="491" left="475" width="305" height="9" font="13">[12] G. Karypis, R. Aggarwal, V. Kumar, and S. Shekhar.</text>
<text top="503" left="501" width="301" height="9" font="13">Multilevel hypergraph partitioning: Applications in VLSI</text>
<text top="515" left="501" width="285" height="9" font="13">domain. VLSI Systems, IEEE Transactions on, 2002.</text>
<text top="529" left="475" width="322" height="9" font="13">[13] H. Kautz, B. Selman, and Y. Jiang. A general stochastic</text>
<text top="541" left="501" width="319" height="9" font="13">approach to solving problems with hard and soft constraints.</text>
<text top="553" left="501" width="292" height="9" font="13">Satisﬁability Problem: Theory and Applications, 1997.</text>
<text top="566" left="475" width="335" height="9" font="13">[14] S. Khot. Ruling out PTAS for graph min-bisection, densest</text>
<text top="578" left="501" width="315" height="9" font="13">subgraph and bipartite clique. In Foundations of Computer</text>
<text top="590" left="501" width="317" height="9" font="13">Science, 2004. Proceedings. 45th Annual IEEE Symposium</text>
<text top="602" left="501" width="165" height="9" font="13">on, pages 136–145. IEEE, 2004.</text>
<text top="615" left="475" width="305" height="9" font="13">[15] A. McCallum, K. Nigam, J. Rennie, and K. Seymore.</text>
<text top="627" left="501" width="324" height="9" font="13">Automating the construction of internet portals with machine</text>
<text top="639" left="501" width="320" height="9" font="13">learning. Information Retrieval Journal, 3(2):127–163, 2000.</text>
<text top="653" left="475" width="97" height="9" font="13">[16] F. Niu, C. R´</text>
<text top="653" left="567" width="237" height="9" font="13">e, A. Doan, and J. Shavlik. Tuﬀy: Scaling up</text>
<text top="665" left="501" width="293" height="9" font="13">Statistical Inference in Markov Logic Networks using an</text>
<text top="677" left="501" width="316" height="10" font="13">RDBMS, http://www.cs.wisc.edu/hazy/papers/tuffy-tr.pdf.</text>
<text top="689" left="501" width="116" height="9" font="13">Working Paper, 2010.</text>
<text top="702" left="475" width="324" height="9" font="13">[17] J. Pearl. Probabilistic Reasoning in Intelligent Systems:</text>
<text top="714" left="501" width="205" height="9" font="13">Networks of Plausible Inference. 1988.</text>
<text top="727" left="475" width="324" height="9" font="13">[18] H. Poon and P. Domingos. Joint inference in information</text>
<text top="739" left="501" width="223" height="9" font="13">extraction. In AAAI, pages 913–918, 2007.</text>
<text top="753" left="475" width="56" height="9" font="13">[19] C. R´</text>
<text top="753" left="525" width="264" height="9" font="13">e, N. N. Dalvi, and D. Suciu. Eﬃcient top-k query</text>
<text top="765" left="501" width="333" height="9" font="13">evaluation on probabilistic data. In ICDE, pages 886–895, 2007.</text>
<text top="778" left="475" width="56" height="9" font="13">[20] C. R´</text>
<text top="778" left="525" width="306" height="9" font="13">e, J. Letchner, M. Balazinska, and D. Suciu. Event queries</text>
<text top="790" left="501" width="289" height="9" font="13">on correlated probabilistic streams. In SIGMOD, 2008.</text>
<text top="804" left="475" width="323" height="9" font="13">[21] M. Richardson and P. Domingos. Markov logic networks.</text>
<text top="816" left="501" width="196" height="9" font="13">Machine Learning, 62:107–136, 2006.</text>
<text top="829" left="475" width="343" height="9" font="13">[22] S. Riedel and I. Meza-Ruiz. Collective semantic role labeling</text>
<text top="841" left="501" width="273" height="9" font="13">with Markov logic. In CoNLL, pages 193–197, 2008.</text>
<text top="854" left="475" width="340" height="9" font="13">[23] P. Sen, A. Deshpande, and L. Getoor. PrDB: Managing and</text>
<text top="866" left="501" width="319" height="9" font="13">exploiting rich correlations in probabilistic databases. VLDB</text>
<text top="878" left="501" width="121" height="9" font="13">J., 18:1065–1090, 2009.</text>
<text top="892" left="475" width="355" height="9" font="13">[24] H. Simon and S. Teng. How good is recursive bisection? SIAM</text>
<text top="904" left="501" width="287" height="9" font="13">Journal on Scientiﬁc Computing, 18:1436–1445, 1997.</text>
<text top="917" left="475" width="331" height="9" font="13">[25] P. Singla and P. Domingos. Entity resolution with Markov</text>
<text top="929" left="501" width="194" height="9" font="13">logic. In ICDE, pages 572–582, 2006.</text>
<text top="943" left="475" width="358" height="9" font="13">[26] V. Vazirani. Approximation Algorithms. Springer Verlag, 2001.</text>
<text top="956" left="475" width="337" height="9" font="13">[27] D. Wang, E. Michelakis, M. Garofalakis, and J. Hellerstein.</text>
<text top="968" left="501" width="319" height="9" font="13">Bayesstore: Managing large, uncertain data repositories with</text>
<text top="980" left="501" width="300" height="9" font="13">probabilistic graphical models. Proceedings of the VLDB</text>
<text top="992" left="501" width="171" height="9" font="13">Endowment, 1(1):340–351, 2008.</text>
<text top="1005" left="475" width="330" height="9" font="13">[28] M. Wellman, J. Breese, and R. Goldman. From knowledge</text>
<text top="1017" left="501" width="331" height="9" font="13">bases to decision models. The Knowledge Engineering Review,</text>
<text top="1029" left="501" width="95" height="9" font="13">7(01):35–53, 1992.</text>
<text top="1043" left="475" width="331" height="9" font="13">[29] F. Wu and D. Weld. Automatically reﬁning the Wikipedia</text>
<text top="1055" left="501" width="303" height="9" font="13">infobox ontology. In Proceeding of the 17th international</text>
<text top="1067" left="501" width="323" height="9" font="13">conference on World Wide Web, pages 635–644. ACM, 2008.</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
<text top="83" left="81" width="93" height="16" font="2">APPENDIX</text>
<text top="110" left="81" width="17" height="16" font="2">A.</text>
<text top="110" left="116" width="290" height="16" font="2">MATERIAL FOR PRELIMINARIES</text>
<text top="141" left="81" width="26" height="16" font="2">A.1</text>
<text top="141" left="125" width="270" height="16" font="2">More Details on the MLN Program</text>
<text top="162" left="94" width="345" height="14" font="3">Rules in MLNs are expressive and may involve data in</text>
<text top="175" left="81" width="252" height="12" font="3">non-trivial ways. For example, consider F</text>
<text top="180" left="333" width="5" height="8" font="1">2</text>
<text top="175" left="339" width="4" height="12" font="3">:</text>
<text top="201" left="103" width="278" height="10" font="4">wrote(x, p1), wrote(x, p2), cat(p1, c) =&gt; cat(p2, c)</text>
<text top="200" left="393" width="13" height="11" font="4">(F</text>
<text top="204" left="406" width="5" height="8" font="1">2</text>
<text top="200" left="413" width="5" height="11" font="4">)</text>
<text top="226" left="87" width="352" height="12" font="3">Intuitively, this rule says that all the papers written by</text>
<text top="242" left="81" width="359" height="12" font="3">a particular person are likely to be in the same category.</text>
<text top="257" left="81" width="279" height="12" font="3">Rules may also have existential quantiﬁers: F</text>
<text top="262" left="360" width="5" height="8" font="1">4</text>
<text top="257" left="372" width="68" height="12" font="3">in Figure 1</text>
<text top="273" left="81" width="359" height="12" font="3">says “any paper in our database must have at least one au-</text>
<text top="289" left="81" width="359" height="12" font="3">thor.” It is also a hard rule, which is indicated by the inﬁnite</text>
<text top="304" left="81" width="359" height="12" font="3">weight, and so no possible world may violate this rule. The</text>
<text top="320" left="81" width="359" height="12" font="3">weight of a formula may also be negative, which eﬀectively</text>
<text top="336" left="81" width="359" height="12" font="3">means that the negation of the formula is likely to hold. For</text>
<text top="352" left="81" width="67" height="12" font="3">example, F</text>
<text top="356" left="148" width="5" height="8" font="1">5</text>
<text top="352" left="159" width="280" height="12" font="3">models our belief that none or very few of the</text>
<text top="367" left="81" width="359" height="14" font="3">unlabeled papers belong to ‘Networking’. Tuffy supports</text>
<text top="383" left="81" width="359" height="14" font="3">all of these features. If the input MLN contains hard rules</text>
<text top="399" left="81" width="359" height="12" font="3">(indicated by a weight of +∞ or −∞), then we insist that</text>
<text top="414" left="81" width="359" height="12" font="3">the set of possible worlds (Inst) only contain worlds that</text>
<text top="430" left="81" width="359" height="12" font="3">satisfy every hard rule with +∞ and violate every rule with</text>
<text top="445" left="81" width="28" height="13" font="3">−∞.</text>
<text top="470" left="81" width="26" height="16" font="2">A.2</text>
<text top="470" left="125" width="175" height="16" font="2">Markov Random Field</text>
<text top="493" left="94" width="345" height="12" font="3">A Boolean Markov Random Field (or Boolean Markov net-</text>
<text top="508" left="81" width="359" height="12" font="3">work) is a model of the joint distribution of a set of Boolean</text>
<text top="524" left="81" width="123" height="12" font="3">random variables ¯</text>
<text top="524" left="193" width="55" height="12" font="3">X = (X</text>
<text top="529" left="248" width="5" height="8" font="1">1</text>
<text top="524" left="254" width="42" height="12" font="3">, . . . , X</text>
<text top="529" left="296" width="9" height="8" font="1">N</text>
<text top="524" left="307" width="9" height="12" font="3">).</text>
<text top="524" left="328" width="111" height="12" font="3">It is deﬁned by a</text>
<text top="540" left="81" width="359" height="12" font="3">hypergraph G = (X, E); for each hyperedge e ∈ E there</text>
<text top="555" left="81" width="295" height="12" font="3">is a potential function (aka “feature”) denoted φ</text>
<text top="560" left="375" width="5" height="8" font="1">e</text>
<text top="555" left="381" width="58" height="12" font="3">, which is</text>
<text top="571" left="81" width="359" height="12" font="3">a function from the values of the set of variables in e to</text>
<text top="587" left="81" width="359" height="12" font="3">non-negative real numbers. This deﬁnes a joint distribution</text>
<text top="602" left="81" width="31" height="12" font="3">Pr( ¯</text>
<text top="602" left="101" width="39" height="12" font="3">X = ¯</text>
<text top="602" left="132" width="79" height="12" font="3">x) as follows:</text>
<text top="634" left="179" width="31" height="12" font="3">Pr( ¯</text>
<text top="634" left="199" width="39" height="12" font="3">X = ¯</text>
<text top="634" left="230" width="28" height="12" font="3">x) =</text>
<text top="625" left="266" width="7" height="12" font="3">1</text>
<text top="643" left="264" width="9" height="12" font="3">Z</text>
<text top="652" left="278" width="21" height="8" font="1">e∈E</text>
<text top="634" left="302" width="8" height="12" font="3">φ</text>
<text top="638" left="310" width="5" height="8" font="1">e</text>
<text top="634" left="316" width="13" height="12" font="3">(¯</text>
<text top="634" left="322" width="8" height="12" font="3">x</text>
<text top="638" left="329" width="5" height="8" font="1">e</text>
<text top="634" left="335" width="5" height="12" font="3">)</text>
<text top="674" left="81" width="49" height="12" font="3">where ¯</text>
<text top="674" left="122" width="63" height="12" font="3">x ∈ {0, 1}</text>
<text top="671" left="186" width="9" height="8" font="1">N</text>
<text top="674" left="196" width="237" height="12" font="3">, Z is a normalization constant and ¯</text>
<text top="674" left="425" width="8" height="12" font="3">x</text>
<text top="679" left="433" width="5" height="8" font="1">e</text>
<text top="690" left="81" width="238" height="12" font="3">denotes the values of the variables in e.</text>
<text top="706" left="94" width="173" height="12" font="3">Fix a set of constants C = {c</text>
<text top="710" left="268" width="5" height="8" font="1">1</text>
<text top="706" left="274" width="37" height="12" font="3">, . . . , c</text>
<text top="710" left="310" width="10" height="8" font="1">M</text>
<text top="705" left="323" width="117" height="15" font="3">}. An MLN deﬁnes</text>
<text top="722" left="81" width="359" height="12" font="3">a Boolean Markov Random Field as follows: for each possi-</text>
<text top="737" left="81" width="359" height="12" font="3">ble grounding of each predicate (i.e., atom), create a node</text>
<text top="753" left="81" width="359" height="12" font="3">(and so a Boolean random variable). For example, there will</text>
<text top="769" left="81" width="359" height="12" font="3">be a node refers(p1, p2) for each pair of papers p1, p2. For</text>
<text top="784" left="81" width="92" height="12" font="3">each formula F</text>
<text top="789" left="172" width="4" height="8" font="1">i</text>
<text top="784" left="182" width="257" height="12" font="3">we ground it in all possible ways, then we</text>
<text top="800" left="81" width="359" height="12" font="3">create a hyperedge e that contains the nodes corresponding</text>
<text top="816" left="81" width="359" height="12" font="3">to all terms in the formula. For example, the key constraint</text>
<text top="831" left="81" width="359" height="12" font="3">creates hyperedges for each paper and all of its potential</text>
<text top="847" left="81" width="63" height="12" font="3">categories.</text>
<text top="872" left="81" width="26" height="16" font="2">A.3</text>
<text top="872" left="125" width="284" height="16" font="2">Optimizing MLN Grounding Process</text>
<text top="894" left="94" width="345" height="14" font="3">Conceptually, we might ground an MLN formula by enu-</text>
<text top="910" left="81" width="359" height="12" font="3">merating all possible assignments to its free variables. How-</text>
<text top="925" left="81" width="359" height="12" font="3">ever, this is both impractical and unnecessary. For example,</text>
<text top="941" left="81" width="87" height="12" font="3">if we ground F</text>
<text top="946" left="168" width="5" height="8" font="1">2</text>
<text top="941" left="178" width="261" height="12" font="3">exhaustively this way, the result would con-</text>
<text top="957" left="81" width="50" height="12" font="3">tain |D|</text>
<text top="954" left="130" width="5" height="8" font="1">4</text>
<text top="957" left="143" width="296" height="12" font="3">ground clauses. Fortunately, in practice a vast</text>
<text top="972" left="81" width="359" height="12" font="3">majority of ground clauses are satisﬁed by evidence regard-</text>
<text top="988" left="81" width="359" height="12" font="3">less of the assignments to unknown truth values; we can</text>
<text top="1004" left="81" width="359" height="12" font="3">safely discard such clauses [40]. Consider the ground clause</text>
<text top="1020" left="81" width="7" height="12" font="3">g</text>
<text top="1023" left="89" width="5" height="8" font="1">¯</text>
<text top="1026" left="87" width="6" height="8" font="1">d</text>
<text top="1020" left="100" width="26" height="12" font="3">of F</text>
<text top="1024" left="126" width="5" height="8" font="1">2</text>
<text top="1020" left="138" width="51" height="12" font="3">where ¯</text>
<text top="1020" left="179" width="260" height="12" font="3">d =(‘Joe’, ‘P2’, ‘P3’, ‘DB’). Suppose that</text>
<text top="1036" left="81" width="272" height="11" font="3">wrote(‘Joe’, ‘P3’) is known to be false, then g</text>
<text top="1039" left="355" width="5" height="8" font="1">¯</text>
<text top="1041" left="353" width="6" height="8" font="1">d</text>
<text top="1035" left="364" width="76" height="12" font="3">will be satis-</text>
<text top="1051" left="81" width="279" height="12" font="3">ﬁed no matter how the other atoms are set (g</text>
<text top="1055" left="361" width="5" height="8" font="1">¯</text>
<text top="1057" left="359" width="6" height="8" font="1">d</text>
<text top="1051" left="371" width="69" height="12" font="3">is an impli-</text>
<text top="1067" left="81" width="191" height="12" font="3">cation). Hence, we can ignore g</text>
<text top="1070" left="274" width="5" height="8" font="1">¯</text>
<text top="1073" left="272" width="6" height="8" font="1">d</text>
<text top="1067" left="283" width="147" height="12" font="3">during the search phase.</text>
<text top="86" left="489" width="345" height="12" font="3">Pushing this idea further, [39] proposes a method called</text>
<text top="102" left="475" width="359" height="14" font="3">“lazy inference” which is implemented by Alchemy. Specif-</text>
<text top="118" left="475" width="359" height="14" font="3">ically, Alchemy works under the more aggressive hypoth-</text>
<text top="133" left="475" width="359" height="12" font="3">esis that most atoms will be false in the ﬁnal solution, and</text>
<text top="149" left="475" width="359" height="12" font="3">in fact throughout the entire execution. To make this idea</text>
<text top="165" left="475" width="359" height="12" font="3">precise, call a ground clause active if it can be violated by</text>
<text top="180" left="475" width="359" height="12" font="3">ﬂipping zero or more active atoms, where an atom is ac-</text>
<text top="196" left="475" width="359" height="12" font="3">tive if its value ﬂips at any point during execution. Observe</text>
<text top="212" left="475" width="312" height="12" font="3">that in the preceding example the ground clause g</text>
<text top="216" left="789" width="5" height="8" font="1">¯</text>
<text top="218" left="787" width="6" height="8" font="1">d</text>
<text top="212" left="799" width="35" height="12" font="3">is not</text>
<text top="228" left="475" width="359" height="14" font="3">active. Alchemy keeps only active ground clauses in mem-</text>
<text top="243" left="475" width="359" height="12" font="3">ory, which can be much smaller than the full set of ground</text>
<text top="259" left="475" width="359" height="12" font="3">clauses. Furthermore, as on-the-ﬂy incremental grounding</text>
<text top="275" left="475" width="359" height="14" font="3">is more expensive than batch grounding, Alchemy uses the</text>
<text top="290" left="475" width="359" height="12" font="3">following one-step look-ahead strategy: assume all atoms</text>
<text top="306" left="475" width="359" height="12" font="3">are inactive and compute active clauses; activate the atoms</text>
<text top="322" left="475" width="359" height="12" font="3">in the grounding result and recompute active clauses. This</text>
<text top="337" left="475" width="359" height="12" font="3">“look-ahead” procedure could be repeatedly applied until</text>
<text top="353" left="475" width="359" height="14" font="3">convergence, resulting in an active closure. Tuffy imple-</text>
<text top="369" left="475" width="176" height="12" font="3">ments this closure algorithm.</text>
<text top="394" left="475" width="26" height="16" font="2">A.4</text>
<text top="394" left="520" width="192" height="16" font="2">The WalkSAT Algorithm</text>
<text top="416" left="489" width="342" height="12" font="3">We list the pseudocode of WalkSAT [13] in Algorithm 1.</text>
<text top="450" left="475" width="250" height="14" font="3">Algorithm 1 The WalkSAT Algorithm</text>
<text top="469" left="475" width="163" height="12" font="3">Input: A: an set of atoms</text>
<text top="484" left="475" width="273" height="12" font="3">Input: C: an set of weighted ground clauses</text>
<text top="500" left="475" width="169" height="12" font="3">Input: MaxFlips, MaxTries</text>
<text top="516" left="475" width="70" height="12" font="3">Output: σ</text>
<text top="513" left="546" width="6" height="8" font="1">∗</text>
<text top="516" left="552" width="156" height="12" font="3">: a truth assignment to A</text>
<text top="532" left="481" width="113" height="12" font="3">1: lowCost ← +∞</text>
<text top="547" left="481" width="188" height="12" font="3">2: for try = 1 to MaxTries do</text>
<text top="563" left="481" width="11" height="12" font="3">3:</text>
<text top="563" left="513" width="227" height="12" font="3">σ ← a random truth assignment to A</text>
<text top="579" left="481" width="11" height="12" font="3">4:</text>
<text top="579" left="513" width="177" height="12" font="3">for flip = 1 to MaxFlips do</text>
<text top="594" left="481" width="11" height="12" font="3">5:</text>
<text top="594" left="526" width="223" height="12" font="3">pick a random c ∈ C that is violated</text>
<text top="610" left="481" width="11" height="12" font="3">6:</text>
<text top="611" left="526" width="264" height="11" font="3">rand ← a random ﬂoat between 0.0 and 1.0</text>
<text top="626" left="481" width="11" height="12" font="3">7:</text>
<text top="626" left="526" width="116" height="12" font="3">if rand ≤ 0.5 then</text>
<text top="641" left="481" width="11" height="12" font="3">8:</text>
<text top="641" left="540" width="145" height="12" font="3">ﬂip a random atom in c</text>
<text top="657" left="481" width="11" height="12" font="3">9:</text>
<text top="657" left="526" width="25" height="12" font="3">else</text>
<text top="673" left="475" width="18" height="12" font="3">10:</text>
<text top="673" left="541" width="272" height="12" font="3">ﬂip an atom in c s.t. the cost decreases most</text>
<text top="688" left="475" width="18" height="12" font="3">11:</text>
<text top="688" left="527" width="147" height="12" font="3">if cost &lt; lowCost then</text>
<text top="704" left="475" width="18" height="12" font="3">12:</text>
<text top="705" left="541" width="116" height="11" font="3">lowCost ← cost, σ</text>
<text top="701" left="657" width="6" height="8" font="1">∗</text>
<text top="703" left="668" width="26" height="13" font="3">← σ</text>
<text top="752" left="475" width="26" height="16" font="2">A.5</text>
<text top="752" left="520" width="168" height="16" font="2">Marginal Inference of</text>
<text top="757" left="693" width="33" height="12" font="3">MLN</text>
<text top="752" left="726" width="7" height="16" font="2">s</text>
<text top="774" left="489" width="345" height="12" font="3">In marginal inference, we estimate the marginal proba-</text>
<text top="790" left="475" width="359" height="12" font="3">bility of atoms. Since this problem is generally intractable,</text>
<text top="806" left="475" width="359" height="12" font="3">we usually resort to sampling methods. The state-of-the-art</text>
<text top="821" left="475" width="359" height="12" font="3">marginal inference algorithm is MC-SAT [38], which is im-</text>
<text top="837" left="475" width="359" height="14" font="3">plemented in both Alchemy and Tuffy. In MC-SAT, each</text>
<text top="853" left="475" width="359" height="12" font="3">sampling step consists of a call to a heuristic SAT sampler</text>
<text top="868" left="475" width="359" height="12" font="3">named SampleSAT [44]. Essentially, SampleSAT is a combi-</text>
<text top="884" left="475" width="359" height="14" font="3">nation of simulated annealing and WalkSAT. And so, Tuffy</text>
<text top="900" left="475" width="359" height="12" font="3">is able to perform marginal inference more eﬃciently as well.</text>
<text top="918" left="475" width="359" height="12" font="3">Alchemy also implements a lifted algorithm for marginal</text>
<text top="931" left="475" width="359" height="12" font="3">inference [42]; it is future work to extend our study to lifted</text>
<text top="947" left="475" width="70" height="12" font="3">approaches.</text>
<text top="981" left="475" width="16" height="16" font="2">B.</text>
<text top="981" left="510" width="227" height="16" font="2">MATERIAL FOR SYSTEMS</text>
<text top="1013" left="475" width="25" height="16" font="2">B.1</text>
<text top="1013" left="519" width="313" height="16" font="2">A Compilation Algorithm for Grounding</text>
<text top="1035" left="489" width="345" height="12" font="3">Algorithm 2 is a basic algorithm of expressing the ground-</text>
<text top="1051" left="475" width="359" height="14" font="3">ing process of an MLN formula in SQL. To support existen-</text>
<text top="1067" left="475" width="359" height="12" font="3">tial quantiﬁers, we used PostgreSQL’s array aggregate fea-</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="81" width="359" height="12" font="3">ture. The ideas in Appendix A.3 can be easily implemented</text>
<text top="102" left="81" width="149" height="12" font="3">on top of this algorithm.</text>
<text top="132" left="81" width="238" height="12" font="3">Algorithm 2 MLN Grounding in SQL</text>
<text top="154" left="81" width="190" height="14" font="3">Input: an MLN formula φ = ∨</text>
<text top="151" left="270" width="6" height="8" font="1">k</text>
<text top="159" left="270" width="18" height="8" font="1">i=1</text>
<text top="154" left="289" width="4" height="12" font="3">l</text>
<text top="158" left="293" width="4" height="8" font="1">i</text>
<text top="154" left="301" width="72" height="12" font="3">where each l</text>
<text top="158" left="373" width="4" height="8" font="1">i</text>
<text top="154" left="381" width="58" height="12" font="3">is a literal</text>
<text top="169" left="104" width="195" height="12" font="3">supported by predicate table r(l</text>
<text top="174" left="299" width="4" height="8" font="1">i</text>
<text top="169" left="304" width="5" height="12" font="3">)</text>
<text top="185" left="81" width="250" height="12" font="3">Output: a SQL query Q that grounds φ</text>
<text top="201" left="87" width="210" height="12" font="3">1: FROM clause of Q includes ‘r(l</text>
<text top="205" left="296" width="4" height="8" font="1">i</text>
<text top="201" left="301" width="15" height="12" font="3">) t</text>
<text top="205" left="316" width="4" height="8" font="1">i</text>
<text top="201" left="321" width="105" height="12" font="3">’ for each literal l</text>
<text top="205" left="425" width="4" height="8" font="1">i</text>
<text top="216" left="87" width="212" height="12" font="3">2: SELECT clause of Q contains ‘t</text>
<text top="221" left="299" width="4" height="8" font="1">i</text>
<text top="216" left="304" width="128" height="12" font="3">.aid’ for each literal l</text>
<text top="221" left="432" width="4" height="8" font="1">i</text>
<text top="232" left="87" width="279" height="12" font="3">3: For each positive (resp. negative) literal l</text>
<text top="237" left="366" width="4" height="8" font="1">i</text>
<text top="232" left="370" width="69" height="12" font="3">, there is a</text>
<text top="248" left="104" width="129" height="12" font="3">WHERE predicate ‘t</text>
<text top="252" left="233" width="4" height="8" font="1">i</text>
<text top="248" left="238" width="144" height="12" font="3">.truth = true’ (resp. ‘t</text>
<text top="252" left="382" width="4" height="8" font="1">i</text>
<text top="248" left="387" width="53" height="12" font="3">.truth =</text>
<text top="263" left="104" width="36" height="12" font="3">false’)</text>
<text top="279" left="87" width="353" height="12" font="3">4: For each variable x in φ, there is a WHERE predicate</text>
<text top="295" left="104" width="274" height="12" font="3">that equates the corresponding columns of t</text>
<text top="299" left="378" width="4" height="8" font="1">i</text>
<text top="295" left="383" width="52" height="12" font="3">’s with l</text>
<text top="299" left="435" width="4" height="8" font="1">i</text>
<text top="310" left="104" width="75" height="12" font="3">containing x</text>
<text top="326" left="87" width="224" height="12" font="3">5: For each constant argument of l</text>
<text top="331" left="310" width="4" height="8" font="1">i</text>
<text top="326" left="315" width="124" height="12" font="3">, there is an equal-</text>
<text top="342" left="104" width="235" height="12" font="3">constant WHERE predicate for table t</text>
<text top="346" left="339" width="4" height="8" font="1">i</text>
<text top="358" left="87" width="353" height="12" font="3">6: Form a conjunction with the above WHERE predicates</text>
<text top="402" left="81" width="25" height="16" font="2">B.2</text>
<text top="402" left="124" width="275" height="16" font="2">Implementing WalkSAT in RDBMS</text>
<text top="424" left="94" width="345" height="12" font="3">WalkSAT is a stochastic local search algorithm; its ran-</text>
<text top="440" left="81" width="359" height="12" font="3">dom access patterns pose considerable challenges to the de-</text>
<text top="456" left="81" width="359" height="14" font="3">sign of Tuffy. More speciﬁcally, the following operations</text>
<text top="471" left="81" width="359" height="12" font="3">are diﬃcult to implement eﬃciently with on-disk data: 1)</text>
<text top="487" left="81" width="359" height="12" font="3">uniformly sample an unsatisﬁed clause; 2) random access</text>
<text top="503" left="81" width="359" height="12" font="3">(read/write) to per-atom or per-clause data structures; and</text>
<text top="518" left="81" width="359" height="12" font="3">3) traverse clauses involving a given atom. Atoms are cached</text>
<text top="534" left="81" width="359" height="12" font="3">as in-memory arrays, while the per-clause data structures</text>
<text top="550" left="81" width="359" height="12" font="3">are read-only. Each step of WalkSAT involves a scan over</text>
<text top="565" left="81" width="318" height="12" font="3">the clauses and many random accesses to the atoms.</text>
<text top="581" left="94" width="345" height="12" font="3">Although our design process iterated over numerous com-</text>
<text top="597" left="81" width="359" height="12" font="3">binations of various design choices, we were still unable to</text>
<text top="612" left="81" width="359" height="12" font="3">reduce the gap as reported in Section 4.2. For example, com-</text>
<text top="628" left="81" width="359" height="12" font="3">pared to clause table scans, one might suspect that index-</text>
<text top="644" left="81" width="359" height="12" font="3">ing could improve search speed by reading less data at each</text>
<text top="660" left="81" width="359" height="12" font="3">step. However, we actually found that the cost of maintain-</text>
<text top="675" left="81" width="359" height="12" font="3">ing indices often outweighs the beneﬁt provided by indexing.</text>
<text top="691" left="81" width="359" height="12" font="3">Moreover, we found it very diﬃcult to get around RDBMS</text>
<text top="707" left="81" width="309" height="12" font="3">overhead such as PostgreSQL’s mandatory MVCC.</text>
<text top="730" left="81" width="25" height="16" font="2">B.3</text>
<text top="730" left="124" width="306" height="16" font="2">Illustrating Tuffy’s Hybrid Architecture</text>
<text top="753" left="94" width="345" height="12" font="3">Figure 7 illustrates the hybrid memory management ap-</text>
<text top="768" left="81" width="359" height="14" font="3">proach of Tuffy. Alchemy is a representative of prior art</text>
<text top="786" left="81" width="359" height="12" font="3">MLN systems, which uses RAM for both grounding and</text>
<text top="800" left="81" width="359" height="14" font="3">search; Tuffy-mm is a version of Tuffy we developed that</text>
<text top="815" left="81" width="359" height="14" font="3">uses an RDBMS for all memory management; and Tuffy</text>
<text top="831" left="81" width="304" height="12" font="3">is the hybrid approach as discussed in Section 3.2.</text>
<text top="904" left="271" width="23" height="7" font="6">RDBMS </text>
<text top="902" left="213" width="15" height="7" font="6">RAM </text>
<text top="948" left="213" width="15" height="7" font="6">RAM </text>
<text top="950" left="271" width="23" height="7" font="6">RDBMS </text>
<text top="948" left="337" width="15" height="7" font="6">RAM </text>
<text top="904" left="334" width="23" height="7" font="6">RDBMS </text>
<text top="900" left="150" width="49" height="11" font="13">Grounding </text>
<text top="946" left="159" width="32" height="11" font="13">Search </text>
<text top="863" left="201" width="42" height="11" font="9"><b>Alchemy </b></text>
<text top="863" left="260" width="46" height="11" font="9"><b>Tuffy-mm </b></text>
<text top="862" left="333" width="25" height="11" font="9"><b>Tuffy </b></text>
<text top="991" left="127" width="267" height="12" font="3">Figure 7: Comparison of architectures</text>
<text top="1028" left="81" width="25" height="16" font="2">B.4</text>
<text top="1028" left="124" width="280" height="16" font="2">MLNs Causing MRF Fragmentation</text>
<text top="1053" left="94" width="345" height="12" font="3">MLN rules usually model the interaction of relationships</text>
<text top="1067" left="81" width="359" height="12" font="3">and attributes of some underlying entities. As such, one can</text>
<text top="86" left="475" width="359" height="12" font="3">deﬁne entity-based transitive closures, which directly cor-</text>
<text top="102" left="475" width="359" height="12" font="3">responds to components in the MRF. Since in real world</text>
<text top="118" left="475" width="359" height="12" font="3">data the interactions are usually sparse, one can expect to</text>
<text top="133" left="475" width="359" height="12" font="3">see multiple components in the MRF. A concrete example is</text>
<text top="149" left="475" width="359" height="12" font="3">the paper classiﬁcation running example, where the primary</text>
<text top="165" left="475" width="359" height="12" font="3">entities are papers, and the interactions are deﬁned by cita-</text>
<text top="180" left="475" width="359" height="12" font="3">tions and common authors. Indeed, our RC dataset yields</text>
<text top="196" left="475" width="310" height="12" font="3">hundreds of components in the MRF (see Table 5).</text>
<text top="220" left="475" width="25" height="16" font="2">B.5</text>
<text top="220" left="519" width="96" height="16" font="2">Theorem 3.1</text>
<text top="251" left="490" width="344" height="12" font="3">Proof of Theorem 3.1. We follow the notations of the</text>
<text top="264" left="475" width="359" height="12" font="3">theorem. Without loss of generality and for ease of notation,</text>
<text top="280" left="475" width="359" height="12" font="3">suppose H = {1, . . . , N }. Denote by Ω the state space of G.</text>
<text top="296" left="475" width="35" height="12" font="3">Let Q</text>
<text top="300" left="510" width="6" height="8" font="1">k</text>
<text top="295" left="521" width="313" height="13" font="3">⊆ Ω be the set of states of G where there are exactly</text>
<text top="311" left="475" width="359" height="12" font="3">k non-optimal components. For any state x ∈ Ω, deﬁne</text>
<text top="327" left="475" width="82" height="12" font="3">H(x) = E[H</text>
<text top="332" left="557" width="6" height="8" font="1">x</text>
<text top="327" left="564" width="16" height="12" font="3">(Q</text>
<text top="332" left="580" width="5" height="8" font="1">0</text>
<text top="327" left="587" width="247" height="12" font="3">)], i.e., the expected hitting time of an</text>
<text top="343" left="475" width="337" height="12" font="3">optimal state from x when running WalkSAT. Deﬁne f</text>
<text top="347" left="812" width="6" height="8" font="1">k</text>
<text top="343" left="823" width="11" height="12" font="3">=</text>
<text top="358" left="475" width="23" height="12" font="3">min</text>
<text top="363" left="498" width="22" height="8" font="1">x∈Q</text>
<text top="366" left="521" width="6" height="7" font="6">k</text>
<text top="358" left="530" width="137" height="12" font="3">H(x); in particular, f</text>
<text top="363" left="667" width="5" height="8" font="1">0</text>
<text top="358" left="680" width="70" height="12" font="3">= 0, and f</text>
<text top="363" left="750" width="5" height="8" font="1">1</text>
<text top="358" left="763" width="71" height="12" font="3">corresponds</text>
<text top="374" left="475" width="359" height="12" font="3">to some state that diﬀers from an optimal by only one bit.</text>
<text top="390" left="475" width="50" height="12" font="3">Deﬁne g</text>
<text top="394" left="525" width="6" height="8" font="1">k</text>
<text top="390" left="536" width="22" height="12" font="3">= f</text>
<text top="394" left="558" width="20" height="8" font="1">k+1</text>
<text top="389" left="582" width="21" height="13" font="3">− f</text>
<text top="394" left="603" width="6" height="8" font="1">k</text>
<text top="390" left="610" width="224" height="12" font="3">. For any x, y ∈ Ω, let Pr(x → y) be</text>
<text top="405" left="475" width="359" height="12" font="3">the transition probability of WalkSAT, i.e., the probability</text>
<text top="421" left="475" width="359" height="12" font="3">that next state will be y given current state x. Note that</text>
<text top="437" left="475" width="359" height="12" font="3">Pr(x → y) &gt; 0 only if y ∈ N (x), where N (x) is the set of</text>
<text top="452" left="475" width="359" height="12" font="3">states that diﬀer from x by at most one bit. For any A ⊆ Ω,</text>
<text top="468" left="475" width="120" height="12" font="3">deﬁne Pr(x → A) =</text>
<text top="475" left="613" width="22" height="8" font="1">y∈A</text>
<text top="468" left="638" width="66" height="12" font="3">Pr(x → y).</text>
<text top="484" left="489" width="87" height="12" font="3">For any x ∈ Q</text>
<text top="489" left="575" width="6" height="8" font="1">k</text>
<text top="484" left="582" width="56" height="12" font="3">, we have</text>
<text top="510" left="512" width="31" height="12" font="3">H(x)</text>
<text top="510" left="556" width="11" height="12" font="3">=</text>
<text top="510" left="581" width="21" height="12" font="3">1 +</text>
<text top="529" left="604" width="21" height="8" font="1">y∈Ω</text>
<text top="510" left="628" width="93" height="12" font="3">Pr(x → y)H(y)</text>
<text top="549" left="556" width="11" height="12" font="3">=</text>
<text top="549" left="581" width="21" height="12" font="3">1 +</text>
<text top="569" left="604" width="80" height="8" font="1">t∈{−1,0,1} y∈Q</text>
<text top="571" left="684" width="18" height="7" font="6">k+t</text>
<text top="549" left="705" width="93" height="12" font="3">Pr(x → y)H(y)</text>
<text top="589" left="556" width="11" height="13" font="3">≥</text>
<text top="590" left="581" width="21" height="12" font="3">1 +</text>
<text top="610" left="604" width="80" height="8" font="1">t∈{−1,0,1} y∈Q</text>
<text top="612" left="684" width="18" height="7" font="6">k+t</text>
<text top="590" left="705" width="69" height="12" font="3">Pr(x → y)f</text>
<text top="595" left="773" width="19" height="8" font="1">k+t</text>
<text top="590" left="793" width="4" height="12" font="3">.</text>
<text top="630" left="475" width="38" height="12" font="3">Deﬁne</text>
<text top="654" left="519" width="9" height="12" font="3">P</text>
<text top="651" left="530" width="6" height="8" font="1">x</text>
<text top="659" left="528" width="8" height="8" font="1">+</text>
<text top="654" left="541" width="75" height="12" font="3">= Pr(x → Q</text>
<text top="659" left="616" width="20" height="8" font="1">k+1</text>
<text top="654" left="637" width="9" height="12" font="3">),</text>
<text top="654" left="662" width="9" height="12" font="3">P</text>
<text top="651" left="673" width="6" height="8" font="1">x</text>
<text top="659" left="671" width="9" height="8" font="1">−</text>
<text top="654" left="684" width="75" height="12" font="3">= Pr(x → Q</text>
<text top="659" left="759" width="20" height="8" font="1">k−1</text>
<text top="654" left="780" width="9" height="12" font="3">),</text>
<text top="678" left="475" width="92" height="12" font="3">then Pr(x → Q</text>
<text top="683" left="567" width="6" height="8" font="1">k</text>
<text top="678" left="574" width="56" height="12" font="3">) = 1 − P</text>
<text top="675" left="632" width="6" height="8" font="1">x</text>
<text top="684" left="630" width="8" height="8" font="1">+</text>
<text top="677" left="643" width="23" height="13" font="3">− P</text>
<text top="675" left="667" width="6" height="8" font="1">x</text>
<text top="683" left="665" width="9" height="8" font="1">−</text>
<text top="678" left="675" width="31" height="12" font="3">, and</text>
<text top="702" left="503" width="80" height="12" font="3">H(x) ≥ 1 + f</text>
<text top="707" left="583" width="6" height="8" font="1">k</text>
<text top="702" left="590" width="38" height="12" font="3">(1 − P</text>
<text top="699" left="630" width="6" height="8" font="1">x</text>
<text top="708" left="628" width="8" height="8" font="1">+</text>
<text top="701" left="640" width="23" height="13" font="3">− P</text>
<text top="699" left="665" width="6" height="8" font="1">x</text>
<text top="707" left="663" width="9" height="8" font="1">−</text>
<text top="702" left="672" width="29" height="12" font="3">) + f</text>
<text top="707" left="701" width="20" height="8" font="1">k−1</text>
<text top="702" left="722" width="9" height="12" font="3">P</text>
<text top="699" left="733" width="6" height="8" font="1">x</text>
<text top="707" left="731" width="9" height="8" font="1">−</text>
<text top="702" left="743" width="21" height="12" font="3">+ f</text>
<text top="707" left="764" width="20" height="8" font="1">k+1</text>
<text top="702" left="784" width="9" height="12" font="3">P</text>
<text top="699" left="795" width="6" height="8" font="1">x</text>
<text top="708" left="793" width="8" height="8" font="1">+</text>
<text top="702" left="802" width="4" height="12" font="3">.</text>
<text top="726" left="489" width="253" height="12" font="3">Since this inequality holds for any x ∈ Q</text>
<text top="731" left="741" width="6" height="8" font="1">k</text>
<text top="726" left="748" width="86" height="12" font="3">, we can ﬁx it</text>
<text top="742" left="475" width="83" height="12" font="3">to be some x</text>
<text top="739" left="558" width="6" height="8" font="1">∗</text>
<text top="741" left="571" width="26" height="13" font="3">∈ Q</text>
<text top="746" left="597" width="6" height="8" font="1">k</text>
<text top="742" left="610" width="55" height="12" font="3">s.t. H(x</text>
<text top="739" left="665" width="6" height="8" font="1">∗</text>
<text top="742" left="671" width="35" height="12" font="3">) = f</text>
<text top="746" left="706" width="6" height="8" font="1">k</text>
<text top="742" left="713" width="59" height="12" font="3">. Then g</text>
<text top="746" left="772" width="20" height="8" font="1">k−1</text>
<text top="742" left="793" width="9" height="12" font="3">P</text>
<text top="739" left="804" width="6" height="8" font="1">x</text>
<text top="736" left="810" width="6" height="7" font="6">∗</text>
<text top="747" left="802" width="9" height="8" font="1">−</text>
<text top="741" left="823" width="11" height="13" font="3">≥</text>
<text top="760" left="475" width="30" height="12" font="3">1 + g</text>
<text top="765" left="506" width="6" height="8" font="1">k</text>
<text top="760" left="512" width="9" height="12" font="3">P</text>
<text top="757" left="523" width="6" height="8" font="1">x</text>
<text top="754" left="529" width="6" height="7" font="6">∗</text>
<text top="765" left="521" width="8" height="8" font="1">+</text>
<text top="760" left="536" width="102" height="12" font="3">, which implies g</text>
<text top="765" left="638" width="20" height="8" font="1">k−1</text>
<text top="759" left="663" width="21" height="13" font="3">≥ g</text>
<text top="765" left="684" width="6" height="8" font="1">k</text>
<text top="760" left="691" width="9" height="12" font="3">P</text>
<text top="757" left="702" width="6" height="8" font="1">x</text>
<text top="754" left="708" width="6" height="7" font="6">∗</text>
<text top="765" left="700" width="8" height="8" font="1">+</text>
<text top="760" left="715" width="16" height="12" font="3">/P</text>
<text top="757" left="732" width="6" height="8" font="1">x</text>
<text top="754" left="739" width="6" height="7" font="6">∗</text>
<text top="765" left="731" width="9" height="8" font="1">−</text>
<text top="760" left="746" width="4" height="12" font="3">.</text>
<text top="776" left="489" width="278" height="12" font="3">Now without loss of generality assume that in x</text>
<text top="772" left="767" width="6" height="8" font="1">∗</text>
<text top="776" left="773" width="18" height="12" font="3">, G</text>
<text top="780" left="791" width="5" height="8" font="1">1</text>
<text top="776" left="798" width="42" height="12" font="3">, . . . , G</text>
<text top="780" left="839" width="6" height="8" font="1">k</text>
<text top="791" left="475" width="146" height="12" font="3">are non-optimal while G</text>
<text top="796" left="621" width="20" height="8" font="1">k+1</text>
<text top="791" left="642" width="42" height="12" font="3">, . . . , G</text>
<text top="796" left="684" width="9" height="8" font="1">N</text>
<text top="791" left="698" width="111" height="12" font="3">are optimal. Let x</text>
<text top="788" left="809" width="6" height="8" font="1">∗</text>
<text top="797" left="809" width="4" height="8" font="1">i</text>
<text top="791" left="820" width="14" height="12" font="3">be</text>
<text top="807" left="475" width="113" height="12" font="3">the projection of x</text>
<text top="804" left="588" width="6" height="8" font="1">∗</text>
<text top="807" left="599" width="30" height="12" font="3">on G</text>
<text top="812" left="629" width="4" height="8" font="1">i</text>
<text top="807" left="634" width="75" height="12" font="3">. Then since</text>
<text top="843" left="490" width="9" height="12" font="3">P</text>
<text top="839" left="501" width="6" height="8" font="1">x</text>
<text top="836" left="507" width="6" height="7" font="6">∗</text>
<text top="848" left="499" width="9" height="8" font="1">−</text>
<text top="843" left="518" width="11" height="12" font="3">=</text>
<text top="830" left="549" width="6" height="8" font="1">k</text>
<text top="840" left="549" width="5" height="8" font="1">1</text>
<text top="833" left="558" width="7" height="12" font="3">v</text>
<text top="838" left="565" width="4" height="8" font="1">i</text>
<text top="833" left="570" width="13" height="12" font="3">(x</text>
<text top="830" left="583" width="6" height="8" font="1">∗</text>
<text top="839" left="583" width="4" height="8" font="1">i</text>
<text top="833" left="589" width="14" height="12" font="3">)α</text>
<text top="838" left="604" width="4" height="8" font="1">i</text>
<text top="833" left="608" width="13" height="12" font="3">(x</text>
<text top="830" left="621" width="6" height="8" font="1">∗</text>
<text top="839" left="621" width="4" height="8" font="1">i</text>
<text top="833" left="628" width="5" height="12" font="3">)</text>
<text top="850" left="567" width="9" height="8" font="1">N</text>
<text top="861" left="567" width="5" height="8" font="1">1</text>
<text top="854" left="579" width="7" height="12" font="3">v</text>
<text top="858" left="586" width="4" height="8" font="1">i</text>
<text top="854" left="591" width="13" height="12" font="3">(x</text>
<text top="852" left="604" width="6" height="8" font="1">∗</text>
<text top="860" left="604" width="4" height="8" font="1">i</text>
<text top="854" left="610" width="5" height="12" font="3">)</text>
<text top="843" left="635" width="4" height="12" font="3">,</text>
<text top="843" left="655" width="9" height="12" font="3">P</text>
<text top="839" left="666" width="6" height="8" font="1">x</text>
<text top="836" left="672" width="6" height="7" font="6">∗</text>
<text top="848" left="664" width="8" height="8" font="1">+</text>
<text top="843" left="683" width="11" height="12" font="3">=</text>
<text top="829" left="714" width="9" height="8" font="1">N</text>
<text top="839" left="714" width="20" height="8" font="1">k+1</text>
<text top="832" left="737" width="7" height="12" font="3">v</text>
<text top="836" left="744" width="5" height="8" font="1">j</text>
<text top="832" left="750" width="13" height="12" font="3">(x</text>
<text top="829" left="763" width="6" height="8" font="1">∗</text>
<text top="837" left="763" width="5" height="8" font="1">j</text>
<text top="832" left="769" width="13" height="12" font="3">)β</text>
<text top="836" left="782" width="5" height="8" font="1">j</text>
<text top="832" left="788" width="13" height="12" font="3">(x</text>
<text top="829" left="801" width="6" height="8" font="1">∗</text>
<text top="837" left="801" width="5" height="8" font="1">j</text>
<text top="832" left="808" width="5" height="12" font="3">)</text>
<text top="850" left="739" width="9" height="8" font="1">N</text>
<text top="861" left="739" width="5" height="8" font="1">1</text>
<text top="854" left="752" width="7" height="12" font="3">v</text>
<text top="858" left="758" width="4" height="8" font="1">i</text>
<text top="854" left="763" width="13" height="12" font="3">(x</text>
<text top="852" left="776" width="6" height="8" font="1">∗</text>
<text top="860" left="776" width="4" height="8" font="1">i</text>
<text top="854" left="783" width="5" height="12" font="3">)</text>
<text top="843" left="815" width="4" height="12" font="3">,</text>
<text top="877" left="475" width="48" height="12" font="3">we have</text>
<text top="910" left="519" width="7" height="12" font="3">g</text>
<text top="915" left="526" width="20" height="8" font="1">k−1</text>
<text top="909" left="551" width="21" height="13" font="3">≥ g</text>
<text top="915" left="572" width="6" height="8" font="1">k</text>
<text top="896" left="595" width="9" height="8" font="1">N</text>
<text top="907" left="595" width="20" height="8" font="1">k+1</text>
<text top="899" left="618" width="7" height="12" font="3">v</text>
<text top="904" left="625" width="5" height="8" font="1">j</text>
<text top="899" left="631" width="13" height="12" font="3">(x</text>
<text top="896" left="644" width="6" height="8" font="1">∗</text>
<text top="905" left="644" width="5" height="8" font="1">j</text>
<text top="899" left="650" width="13" height="12" font="3">)β</text>
<text top="904" left="663" width="5" height="8" font="1">j</text>
<text top="899" left="669" width="13" height="12" font="3">(x</text>
<text top="896" left="683" width="6" height="8" font="1">∗</text>
<text top="905" left="683" width="5" height="8" font="1">j</text>
<text top="899" left="689" width="5" height="12" font="3">)</text>
<text top="918" left="603" width="6" height="8" font="1">k</text>
<text top="929" left="603" width="5" height="8" font="1">1</text>
<text top="921" left="612" width="7" height="12" font="3">v</text>
<text top="926" left="618" width="4" height="8" font="1">i</text>
<text top="921" left="623" width="13" height="12" font="3">(x</text>
<text top="919" left="636" width="6" height="8" font="1">∗</text>
<text top="928" left="636" width="4" height="8" font="1">i</text>
<text top="921" left="643" width="14" height="12" font="3">)α</text>
<text top="926" left="657" width="4" height="8" font="1">i</text>
<text top="921" left="662" width="13" height="12" font="3">(x</text>
<text top="919" left="675" width="6" height="8" font="1">∗</text>
<text top="928" left="675" width="4" height="8" font="1">i</text>
<text top="921" left="682" width="5" height="12" font="3">)</text>
<text top="909" left="700" width="21" height="13" font="3">≥ g</text>
<text top="915" left="721" width="6" height="8" font="1">k</text>
<text top="901" left="730" width="54" height="12" font="3">r(N − k)</text>
<text top="919" left="753" width="7" height="12" font="3">k</text>
<text top="910" left="786" width="4" height="12" font="3">,</text>
<text top="945" left="475" width="359" height="12" font="3">where the second inequality follows from the deﬁnition of r.</text>
<text top="960" left="489" width="208" height="12" font="3">For all k ≤ rN/(r + 2), we have g</text>
<text top="965" left="696" width="20" height="8" font="1">k−1</text>
<text top="960" left="722" width="29" height="13" font="3">≥ 2g</text>
<text top="965" left="751" width="6" height="8" font="1">k</text>
<text top="960" left="757" width="54" height="12" font="3">. Since g</text>
<text top="965" left="812" width="6" height="8" font="1">k</text>
<text top="960" left="823" width="11" height="13" font="3">≥</text>
<text top="978" left="475" width="88" height="12" font="3">1 for any k, f</text>
<text top="982" left="563" width="5" height="8" font="1">1</text>
<text top="978" left="576" width="24" height="12" font="3">= g</text>
<text top="982" left="600" width="5" height="8" font="1">0</text>
<text top="977" left="613" width="24" height="13" font="3">≥ 2</text>
<text top="975" left="637" width="48" height="8" font="1">rN/(r+2)</text>
<text top="978" left="685" width="149" height="12" font="3">. That is, not aware of</text>
<text top="993" left="475" width="359" height="12" font="3">components, WalkSAT would take an exponential number</text>
<text top="1009" left="475" width="359" height="12" font="3">of steps in expectation to correct the last bit to reach an</text>
<text top="1025" left="475" width="58" height="12" font="3">optimum.</text>
<text top="1051" left="475" width="359" height="12" font="3">According to this theorem, the gap on Example 1 is at least</text>
<text top="1067" left="475" width="7" height="12" font="3">2</text>
<text top="1064" left="482" width="20" height="8" font="1">N/3</text>
<text top="1067" left="503" width="331" height="12" font="3">; in fact, a more detailed analysis reveals that the gap</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1188" width="918">
<text top="155" left="186" width="13" height="9" font="1">500</text>
<text top="132" left="182" width="18" height="9" font="1">1000</text>
<text top="108" left="182" width="18" height="9" font="1">1500</text>
<text top="85" left="182" width="18" height="9" font="1">2000</text>
<text top="167" left="205" width="4" height="9" font="1">0</text>
<text top="167" left="236" width="9" height="9" font="1">20</text>
<text top="167" left="269" width="9" height="9" font="1">40</text>
<text top="167" left="302" width="9" height="9" font="1">60</text>
<text top="167" left="336" width="9" height="9" font="1">80</text>
<text top="125" left="177" width="0" height="12" font="10"><b>cos</b></text>
<text top="109" left="177" width="0" height="12" font="10"><b>t </b></text>
<text top="180" left="248" width="54" height="12" font="10"><b>time (sec) </b></text>
<text top="91" left="219" width="113" height="10" font="8"><b>Performance on Example 1 </b></text>
<text top="114" left="255" width="69" height="9" font="1">Tuffy-p (diamonds) </text>
<text top="125" left="255" width="70" height="9" font="1">Alchemy (triangles) </text>
<text top="144" left="255" width="20" height="9" font="1">Tuffy </text>
<text top="201" left="102" width="317" height="12" font="3">Figure 8: Eﬀect of partitioning on Example 1</text>
<text top="229" left="81" width="59" height="12" font="3">is at least</text>
<text top="226" left="151" width="24" height="8" font="1">N −1</text>
<text top="235" left="159" width="8" height="7" font="6">N</text>
<text top="242" left="161" width="5" height="7" font="6">2</text>
<text top="229" left="186" width="38" height="13" font="3">≈ Θ(2</text>
<text top="227" left="224" width="9" height="8" font="1">N</text>
<text top="229" left="234" width="7" height="12" font="3">/</text>
<text top="217" left="241" width="12" height="13" font="3">√</text>
<text top="229" left="253" width="187" height="12" font="3">N ). Figure 8 shows the exper-</text>
<text top="249" left="81" width="359" height="14" font="3">iment results of running Alchemy, Tuffy, and Tuffy-p</text>
<text top="265" left="81" width="359" height="14" font="3">(i.e., Tuffy without partitioning) on Example 1 with 1000</text>
<text top="280" left="81" width="359" height="12" font="3">components. Note that the analysis of Theorem 3.1 actually</text>
<text top="296" left="81" width="359" height="12" font="3">applies to not only WalkSAT, but stochastic local search in</text>
<text top="312" left="81" width="359" height="12" font="3">general. Since stochastic local search algorithms are used</text>
<text top="328" left="81" width="359" height="12" font="3">in many statistical models, we believe that our observation</text>
<text top="343" left="81" width="359" height="12" font="3">here and corresponding techniques have much wider impli-</text>
<text top="359" left="81" width="174" height="14" font="3">cations than MLN inference.</text>
<text top="383" left="81" width="25" height="16" font="2">B.6</text>
<text top="383" left="124" width="234" height="16" font="2">Hardness of MRF Partitioning</text>
<text top="406" left="94" width="345" height="12" font="3">A bisection of a graph G = (V, E) with an even number</text>
<text top="421" left="81" width="246" height="12" font="3">of vertices is a pair of disjoint subsets V</text>
<text top="426" left="327" width="5" height="8" font="1">1</text>
<text top="421" left="333" width="14" height="12" font="3">, V</text>
<text top="426" left="347" width="5" height="8" font="1">2</text>
<text top="421" left="359" width="81" height="13" font="3">⊂ V of equal</text>
<text top="437" left="81" width="359" height="12" font="3">size. The cost of a bisection is the number of edges adjacent</text>
<text top="453" left="81" width="57" height="12" font="3">to both V</text>
<text top="457" left="138" width="5" height="8" font="1">1</text>
<text top="453" left="149" width="35" height="12" font="3">and V</text>
<text top="457" left="184" width="5" height="8" font="1">2</text>
<text top="453" left="190" width="249" height="12" font="3">. The problem of Minimum Graph Bisec-</text>
<text top="468" left="81" width="359" height="12" font="3">tion (MGB) is to ﬁnd a bisection with minimum cost. This</text>
<text top="484" left="81" width="359" height="12" font="3">problem admits no PTAS [14]. The hardness of MGB di-</text>
<text top="500" left="81" width="359" height="12" font="3">rectly implies the hardness of partitioning MRFs. As such,</text>
<text top="515" left="81" width="359" height="12" font="3">one may wonder if it still holds w.r.t. the domain size for</text>
<text top="531" left="81" width="359" height="12" font="3">a given MLN program (hence of size O(1)). The following</text>
<text top="547" left="81" width="229" height="12" font="3">theorem shows that the answer is yes.</text>
<text top="574" left="96" width="344" height="12" font="3">Theorem B.1. MGB can be reduced to the problem of</text>
<text top="588" left="81" width="359" height="12" font="3">ﬁnding a minimum bisection of the MRF generated an MLN</text>
<text top="603" left="81" width="76" height="12" font="3">of size O(1).</text>
<text top="628" left="96" width="344" height="12" font="3">Proof. Consider the MLN that contains a single formula</text>
<text top="642" left="81" width="130" height="12" font="3">of the following form:</text>
<text top="666" left="200" width="121" height="12" font="3">p(x), r(x, y) → p(y),</text>
<text top="690" left="81" width="359" height="12" font="3">where p is query and r is evidence. For any graph G =</text>
<text top="706" left="81" width="359" height="12" font="3">(V, E), we can set the domain of the predicates to be V ,</text>
<text top="721" left="81" width="359" height="12" font="3">and let r = E. The MRF generated by the above MLN</text>
<text top="737" left="81" width="321" height="12" font="3">(using techniques in Appendix A.3) is identical to G.</text>
<text top="762" left="81" width="25" height="16" font="2">B.7</text>
<text top="762" left="124" width="222" height="16" font="2">MRF Partitioning Algorithm</text>
<text top="784" left="94" width="345" height="12" font="3">We provide a very simple MRF partitioning algorithm</text>
<text top="800" left="81" width="359" height="12" font="3">(Algorithm 3) that is inspired by Kruskal’s minimum span-</text>
<text top="816" left="81" width="359" height="12" font="3">ning tree algorithm. It agglomeratively merges atoms into</text>
<text top="831" left="81" width="359" height="12" font="3">partitions with one scan of the clauses sorted in the (de-</text>
<text top="847" left="81" width="359" height="12" font="3">scending) absolute values of weights. The hope is to avoid</text>
<text top="863" left="81" width="359" height="12" font="3">cutting high-weighted clauses, thereby (heuristically) mini-</text>
<text top="878" left="81" width="151" height="12" font="3">mizing weighted cut size.</text>
<text top="894" left="94" width="345" height="12" font="3">To explain the partitioning procedure, we provide the fol-</text>
<text top="910" left="81" width="359" height="12" font="3">lowing deﬁnitions. Each clause c in the MRF G = (V, E) is</text>
<text top="925" left="81" width="359" height="12" font="3">assigned to an atom in c. A partition of the MRF is a sub-</text>
<text top="941" left="81" width="49" height="12" font="3">graph G</text>
<text top="946" left="130" width="4" height="8" font="1">i</text>
<text top="941" left="139" width="28" height="12" font="3">= (V</text>
<text top="946" left="167" width="4" height="8" font="1">i</text>
<text top="941" left="171" width="16" height="12" font="3">, E</text>
<text top="946" left="188" width="4" height="8" font="1">i</text>
<text top="941" left="192" width="190" height="12" font="3">) deﬁned by a subset of atoms V</text>
<text top="946" left="382" width="4" height="8" font="1">i</text>
<text top="940" left="391" width="44" height="13" font="3">⊆ V ; E</text>
<text top="946" left="435" width="4" height="8" font="1">i</text>
<text top="957" left="81" width="280" height="12" font="3">is the set of clauses assigned to some atom in V</text>
<text top="961" left="361" width="4" height="8" font="1">i</text>
<text top="957" left="365" width="74" height="12" font="3">. The size of</text>
<text top="972" left="81" width="11" height="12" font="3">G</text>
<text top="977" left="92" width="4" height="8" font="1">i</text>
<text top="972" left="100" width="339" height="12" font="3">as referred to by Algorithm 3 can be any monotone func-</text>
<text top="988" left="81" width="56" height="12" font="3">tion in G</text>
<text top="993" left="137" width="4" height="8" font="1">i</text>
<text top="988" left="141" width="298" height="12" font="3">; in practice, it is deﬁned to be the total number</text>
<text top="1004" left="81" width="157" height="12" font="3">of literals and atoms in G</text>
<text top="1008" left="238" width="4" height="8" font="1">i</text>
<text top="1004" left="243" width="197" height="12" font="3">. Note that when the parameter</text>
<text top="1020" left="81" width="359" height="12" font="3">β is set to +∞, the output is the connected components of</text>
<text top="1035" left="81" width="15" height="12" font="3">G.</text>
<text top="1051" left="94" width="345" height="12" font="3">Our implementation of Algorithm 3 only uses RAM to</text>
<text top="1067" left="81" width="359" height="12" font="3">maintain a union-ﬁnd structure of the nodes, and performs</text>
<text top="85" left="475" width="326" height="12" font="3">Algorithm 3 A Simple MRF Partitioning Algorithm</text>
<text top="104" left="475" width="359" height="14" font="3">Input: an MRF G = (V, E) with clause weights w : E → R</text>
<text top="120" left="475" width="184" height="12" font="3">Input: partition size bound β</text>
<text top="136" left="475" width="359" height="12" font="3">Output: a partitioning of V s.t. the size of each partition</text>
<text top="151" left="499" width="112" height="12" font="3">is no larger than β</text>
<text top="167" left="481" width="288" height="12" font="3">1: Initialize hypergraph H = (V, F ) with F = ∅</text>
<text top="183" left="481" width="264" height="12" font="3">2: for all e ∈ E in |w|-descending order do</text>
<text top="198" left="481" width="11" height="12" font="3">3:</text>
<text top="198" left="513" width="321" height="12" font="3">F ← F ∪ e if afterwards no component in H is larger</text>
<text top="214" left="513" width="40" height="12" font="3">than β</text>
<text top="230" left="481" width="352" height="12" font="3">4: return the collection of per-component atom sets in H</text>
<text top="266" left="475" width="359" height="12" font="3">all other operations in the RDBMS. For example, we use</text>
<text top="282" left="475" width="359" height="12" font="3">SQL queries to “assign” clauses to atoms and to compute</text>
<text top="298" left="475" width="301" height="12" font="3">the partition of clauses from a partition of atoms.</text>
<text top="323" left="475" width="25" height="16" font="2">B.8</text>
<text top="323" left="519" width="228" height="16" font="2">Tradeoff of MRF Partitioning</text>
<text top="346" left="489" width="345" height="12" font="3">Clearly, partitioning might be detrimental to search speed</text>
<text top="361" left="475" width="359" height="12" font="3">if the cut size is large. Furthermore, given multiple parti-</text>
<text top="377" left="475" width="359" height="12" font="3">tioning options, how do we decide which one is better? As</text>
<text top="393" left="475" width="359" height="12" font="3">a baseline, we provide the following formula to (roughly) es-</text>
<text top="409" left="475" width="359" height="12" font="3">timate the beneﬁt (if positive) or detriment (if negative) of</text>
<text top="424" left="475" width="87" height="12" font="3">a partitioning:</text>
<text top="457" left="567" width="40" height="12" font="3">W = 2</text>
<text top="451" left="609" width="8" height="7" font="6">N</text>
<text top="458" left="611" width="5" height="7" font="6">3</text>
<text top="456" left="623" width="22" height="13" font="3">− T</text>
<text top="447" left="649" width="88" height="13" font="3">|#cut clauses|</text>
<text top="465" left="684" width="19" height="13" font="3">|E|</text>
<text top="457" left="739" width="4" height="12" font="3">,</text>
<text top="490" left="475" width="359" height="12" font="3">where N is the estimated number of components with posi-</text>
<text top="506" left="475" width="359" height="12" font="3">tive lowest cost, T is the total number of WalkSAT steps in</text>
<text top="521" left="475" width="359" height="12" font="3">one round of Gauss-Seidel, and |E| is the total number of</text>
<text top="537" left="475" width="359" height="12" font="3">clauses. The ﬁrst term roughly captures the speed-up as a</text>
<text top="553" left="475" width="359" height="12" font="3">result of Theorem 3.1, and the second term roughly captures</text>
<text top="569" left="475" width="224" height="12" font="3">the slow-down caused by cut clauses.</text>
<text top="584" left="489" width="345" height="12" font="3">Empirically however, we ﬁnd this formula to be rather</text>
<text top="600" left="475" width="359" height="12" font="3">conservative compared to experimental results that gener-</text>
<text top="616" left="475" width="359" height="12" font="3">ally favor much more aggressive partitioning. In the techni-</text>
<text top="631" left="475" width="359" height="12" font="3">cal report [16] (Section 5), we present a much more detailed</text>
<text top="647" left="475" width="359" height="12" font="3">discussion. The main idea is to ﬁnely model the elements</text>
<text top="663" left="475" width="359" height="12" font="3">of the tradeoﬀ by taking into account connectivity and the</text>
<text top="678" left="475" width="178" height="12" font="3">inﬂuence of individual atoms.</text>
<text top="713" left="475" width="17" height="16" font="2">C.</text>
<text top="713" left="511" width="275" height="16" font="2">MATERIAL FOR EXPERIMENTS</text>
<text top="745" left="475" width="26" height="16" font="2">C.1</text>
<text top="745" left="520" width="234" height="16" font="2">Alternative Search Algorithms</text>
<text top="768" left="489" width="345" height="12" font="3">As shown in Section 4.3, RDBMS-based implementation</text>
<text top="783" left="475" width="359" height="12" font="3">of WalkSAT is several orders of magnitude slower than the</text>
<text top="799" left="475" width="359" height="12" font="3">in-memory counter part. This gap is consistent with the</text>
<text top="815" left="475" width="177" height="12" font="3">I/O performance of disk vs.</text>
<text top="815" left="666" width="88" height="12" font="3">main memory.</text>
<text top="815" left="767" width="67" height="12" font="3">One might</text>
<text top="830" left="475" width="359" height="12" font="3">imagine some clever caching schemes for WalkSAT, but even</text>
<text top="846" left="475" width="359" height="12" font="3">assuming that a ﬂip incurs only one random I/O operation</text>
<text top="862" left="475" width="359" height="12" font="3">(which is usually on the order of 10 ms), the ﬂipping rate</text>
<text top="877" left="475" width="359" height="12" font="3">of RDBMS-based search is still no more than 100 ﬂips/sec.</text>
<text top="893" left="475" width="359" height="12" font="3">Thus, it is highly unlikely that disk-based search implemen-</text>
<text top="909" left="475" width="333" height="12" font="3">tations could catch up to their in-memory counterpart.</text>
<text top="934" left="475" width="26" height="16" font="2">C.2</text>
<text top="934" left="520" width="254" height="16" font="2">Lesion Study of Tuffy Grounding</text>
<text top="957" left="489" width="345" height="12" font="3">To understand which part of the RDBMS contributes the</text>
<text top="972" left="475" width="359" height="14" font="3">most to Tuffy’s fast grounding speed, we conduct a lesion</text>
<text top="988" left="475" width="359" height="12" font="3">study by comparing the grounding time in three settings: 1)</text>
<text top="1004" left="475" width="359" height="12" font="3">full optimizer, where the RDBMS is free to optimize SQL</text>
<text top="1020" left="475" width="359" height="12" font="3">queries in all ways; 2) ﬁxed join order, where we force</text>
<text top="1035" left="475" width="359" height="14" font="3">the RDBMS to use the same join order as Alchemy does;</text>
<text top="1051" left="475" width="359" height="12" font="3">3) ﬁxed join algorithm, where we force the RDBMS to</text>
<text top="1067" left="475" width="359" height="12" font="3">use nested loop join only. The results are shown in Table 6.</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1188" width="918">
<text top="82" left="238" width="19" height="11" font="4">LP</text>
<text top="82" left="278" width="15" height="11" font="4">IE</text>
<text top="82" left="333" width="21" height="11" font="4">RC</text>
<text top="82" left="396" width="21" height="11" font="4">ER</text>
<text top="96" left="122" width="78" height="11" font="4">Full optimizer</text>
<text top="96" left="250" width="6" height="11" font="4">6</text>
<text top="96" left="280" width="13" height="11" font="4">13</text>
<text top="96" left="342" width="13" height="11" font="4">40</text>
<text top="96" left="397" width="19" height="11" font="4">106</text>
<text top="111" left="116" width="89" height="11" font="4">Fixed join order</text>
<text top="111" left="250" width="6" height="11" font="4">7</text>
<text top="111" left="280" width="13" height="11" font="4">13</text>
<text top="111" left="342" width="13" height="11" font="4">43</text>
<text top="111" left="397" width="19" height="11" font="4">111</text>
<text top="125" left="104" width="114" height="11" font="4">Fixed join algorithm</text>
<text top="125" left="238" width="19" height="11" font="4">112</text>
<text top="125" left="274" width="19" height="11" font="4">306</text>
<text top="125" left="309" width="45" height="11" font="4">&gt;36,000</text>
<text top="125" left="371" width="45" height="11" font="4">&gt;16,000</text>
<text top="154" left="135" width="251" height="12" font="3">Table 6: Grounding time in seconds</text>
<text top="184" left="295" width="15" height="11" font="4">IE</text>
<text top="184" left="327" width="21" height="11" font="4">RC</text>
<text top="198" left="189" width="64" height="11" font="4">Tuﬀy-batch</text>
<text top="198" left="291" width="19" height="11" font="4">448</text>
<text top="198" left="329" width="19" height="11" font="4">133</text>
<text top="212" left="207" width="29" height="11" font="4">Tuﬀy</text>
<text top="212" left="291" width="19" height="11" font="4">117</text>
<text top="212" left="335" width="13" height="11" font="4">77</text>
<text top="226" left="172" width="99" height="11" font="4">Tuﬀy+parallelism</text>
<text top="226" left="298" width="13" height="11" font="4">28</text>
<text top="226" left="335" width="13" height="11" font="4">42</text>
<text top="256" left="86" width="349" height="12" font="3">Table 7: Comparison of execution time in seconds</text>
<text top="285" left="81" width="359" height="12" font="3">Clearly, being able to use various join algorithms is the key</text>
<text top="301" left="81" width="202" height="14" font="3">to Tuffy’s fast grounding speed.</text>
<text top="325" left="81" width="26" height="16" font="2">C.3</text>
<text top="325" left="125" width="229" height="16" font="2">Data Loading and Parallelism</text>
<text top="348" left="94" width="345" height="12" font="3">To validate the importance of batch data loading and</text>
<text top="364" left="81" width="359" height="14" font="3">parallelism (Section 3.3), we run three versions of Tuffy</text>
<text top="379" left="81" width="359" height="12" font="3">on the IE and RC datasets: 1) Tuﬀy, which has batch</text>
<text top="395" left="81" width="359" height="12" font="3">loading but no parallelism; 2) Tuﬀy-batch, which loads</text>
<text top="411" left="81" width="359" height="12" font="3">components one by one and does not use parallelism; and</text>
<text top="426" left="81" width="359" height="12" font="3">3) Tuﬀy+parallelism, which has both batch loading and</text>
<text top="442" left="81" width="359" height="12" font="3">parallelism. We use the same WalkSAT parameters on each</text>
<text top="458" left="81" width="124" height="12" font="3">component (up to 10</text>
<text top="455" left="204" width="5" height="8" font="1">6</text>
<text top="458" left="214" width="225" height="12" font="3">ﬂips per component) and run all three</text>
<text top="473" left="81" width="359" height="12" font="3">settings on the same machine with an 8-core Xeon CPU. Ta-</text>
<text top="489" left="81" width="341" height="12" font="3">ble 7 shows the end-to-end running time of each setting.</text>
<text top="505" left="94" width="345" height="12" font="3">Clearly, loading the components one by one incurs signif-</text>
<text top="520" left="81" width="359" height="12" font="3">icant I/O cost on both datasets. The grounding + parti-</text>
<text top="536" left="81" width="359" height="12" font="3">tioning time of IE and RC are 11 seconds and 35 seconds,</text>
<text top="552" left="81" width="359" height="12" font="3">respectively. Hence, Tuﬀy+parallelism achieved roughly 6-</text>
<text top="568" left="81" width="195" height="12" font="3">time speed up on both datasets.</text>
<text top="588" left="81" width="17" height="16" font="2">D.</text>
<text top="588" left="116" width="252" height="16" font="2">EXTENDED RELATED WORK</text>
<text top="610" left="94" width="345" height="12" font="3">The idea of using the stochastic local search algorithm</text>
<text top="628" left="81" width="359" height="12" font="3">WalkSAT to ﬁnd the most likely world is due to Kautz et</text>
<text top="641" left="81" width="359" height="12" font="3">al. [13]. Singla and Domingos [41] proposed lazy grounding</text>
<text top="657" left="81" width="359" height="14" font="3">and applies it to WalkSAT, resulting in an algorithm called</text>
<text top="675" left="81" width="359" height="12" font="3">LazySAT that is implemented in Alchemy. The idea of ig-</text>
<text top="688" left="81" width="359" height="12" font="3">noring ground clauses that are satisﬁed by evidence is high-</text>
<text top="704" left="81" width="359" height="14" font="3">lighted as an eﬀective way of speeding up the MLN ground-</text>
<text top="720" left="81" width="359" height="12" font="3">ing process in Shavlik and Natarajan [40], which formulates</text>
<text top="736" left="81" width="359" height="12" font="3">the grounding process as nested loops and provides heuris-</text>
<text top="751" left="81" width="359" height="12" font="3">tics to approximate the optimal looping order. Mihalkova</text>
<text top="767" left="81" width="359" height="12" font="3">and Mooney [35] also employ a bottom-up approach, but</text>
<text top="783" left="81" width="359" height="12" font="3">they address structure learning of MLNs whereas we focus</text>
<text top="798" left="81" width="359" height="12" font="3">on inference. As an orthogonal approach to scaling MLN in-</text>
<text top="814" left="81" width="359" height="12" font="3">ference, Mihalkova and Richardson [36] study how to avoid</text>
<text top="830" left="81" width="359" height="12" font="3">redundant computation by clustering similar query literals.</text>
<text top="845" left="81" width="359" height="12" font="3">It is an interesting problem to incorporate their techniques</text>
<text top="861" left="81" width="359" height="14" font="3">into Tuffy. Lifted inference (e.g., [42]) involves performing</text>
<text top="877" left="81" width="359" height="14" font="3">inference in MLNs without completely grounding them into</text>
<text top="892" left="81" width="359" height="14" font="3">MRFs. It is interesting future work to extend Tuffy to</text>
<text top="908" left="81" width="359" height="12" font="3">perform lifted inference. Knowledge-based model construc-</text>
<text top="924" left="81" width="359" height="12" font="3">tion [28] is a technique that, given a query, ﬁnds the minimal</text>
<text top="940" left="81" width="359" height="12" font="3">relevant portion of a graph; although the resulting subgraph</text>
<text top="955" left="81" width="359" height="12" font="3">may contain multiple components, the downstream inference</text>
<text top="971" left="81" width="359" height="12" font="3">algorithm may not be aware of it and thereby cannot beneﬁt</text>
<text top="987" left="81" width="185" height="12" font="3">from the speedup in Thm. 3.1.</text>
<text top="86" left="489" width="345" height="14" font="3">While Tuffy employs the simple WalkSAT algorithm,</text>
<text top="102" left="475" width="359" height="12" font="3">there are more advanced techniques for MAP inference [31,</text>
<text top="118" left="475" width="359" height="12" font="3">33]; we plan to integrate them into upcoming versions of</text>
<text top="136" left="475" width="359" height="12" font="3">Tuffy. For hypergraph partitioning, there are established</text>
<text top="149" left="475" width="359" height="12" font="3">solutions such as hMETIS [12]. However, existing imple-</text>
<text top="161" left="475" width="359" height="12" font="3">mentations of them are limited by memory size, and it is</text>
<text top="177" left="475" width="359" height="12" font="3">future work to adapt these algorithms to on-disk data; this</text>
<text top="193" left="475" width="359" height="12" font="3">motivated us to design Algorithm 3. The technique of cut-</text>
<text top="208" left="475" width="359" height="12" font="3">set conditioning [17] from the SAT and probabilistic infer-</text>
<text top="224" left="475" width="359" height="12" font="3">ence literature is closely related to our partitioning tech-</text>
<text top="240" left="475" width="359" height="12" font="3">nique [30, 37]. Cutset conditioning recursively conditions on</text>
<text top="256" left="475" width="359" height="12" font="3">cutsets of graphical models, and at each step exhaustively</text>
<text top="271" left="475" width="359" height="12" font="3">enumerates all conﬁgurations of the cut, which is imprac-</text>
<text top="287" left="475" width="359" height="12" font="3">tical in our scenario: even for small datasets, the cut size</text>
<text top="303" left="475" width="359" height="12" font="3">can easily be thousands, making exhaustive enumeration in-</text>
<text top="318" left="475" width="359" height="12" font="3">feasible. Instead, we use a Gauss-Seidel strategy, which we</text>
<text top="334" left="475" width="359" height="12" font="3">show is eﬃcient and eﬀective. Additionally, our conceptual</text>
<text top="350" left="475" width="359" height="12" font="3">goals are diﬀerent: our goal is to ﬁnd an analytic formula</text>
<text top="365" left="475" width="359" height="12" font="3">that quantiﬁes the eﬀect of partitioning and then, we use</text>
<text top="381" left="475" width="359" height="12" font="3">this formula to optimize the IO and scheduling behavior of</text>
<text top="397" left="475" width="359" height="12" font="3">a class of local search algorithms; in contrast, prior work</text>
<text top="412" left="475" width="281" height="12" font="3">focuses on designing new inference algorithms.</text>
<text top="428" left="489" width="345" height="14" font="3">There are statistical-logical frameworks similar to MLNs,</text>
<text top="444" left="475" width="359" height="12" font="3">such as Probabilistic Relational Models [32] and Relational</text>
<text top="460" left="475" width="359" height="12" font="3">Markov Models [43]. Inference on those models also requires</text>
<text top="475" left="475" width="359" height="12" font="3">grounding and search, and we are optimistic that the lessons</text>
<text top="491" left="475" width="305" height="12" font="3">we learned with MLNs carry over to these models.</text>
<text top="516" left="475" width="16" height="16" font="2">E.</text>
<text top="516" left="510" width="121" height="16" font="2">REFERENCES</text>
<text top="537" left="475" width="322" height="9" font="13">[30] D. Allen and A. Darwiche. New advances in inference by</text>
<text top="549" left="501" width="258" height="9" font="13">recursive conditioning. In UAI, pages 2–10, 2003.</text>
<text top="563" left="475" width="303" height="9" font="13">[31] J. Duchi, D. Tarlow, G. Elidan, and D. Koller. Using</text>
<text top="575" left="501" width="281" height="9" font="13">combinatorial optimization within max-product belief</text>
<text top="587" left="501" width="230" height="9" font="13">propagation. In NIPS, pages 369–376, 2007.</text>
<text top="600" left="475" width="339" height="9" font="13">[32] N. Friedman, L. Getoor, D. Koller, and A. Pfeﬀer. Learning</text>
<text top="612" left="501" width="311" height="9" font="13">probabilistic relational models. In IJCAI, pages 1300–1309,</text>
<text top="624" left="501" width="27" height="9" font="13">1999.</text>
<text top="637" left="475" width="350" height="9" font="13">[33] R. Gupta, A. Diwan, and S. Sarawagi. Eﬃcient inference with</text>
<text top="649" left="501" width="268" height="9" font="13">cardinality-based clique potentials. In ICML, 2007.</text>
<text top="663" left="475" width="322" height="9" font="13">[34] H. Kautz, B. Selman, and Y. Jiang. A general stochastic</text>
<text top="675" left="501" width="319" height="9" font="13">approach to solving problems with hard and soft constraints.</text>
<text top="687" left="501" width="292" height="9" font="13">Satisﬁability Problem: Theory and Applications, 1997.</text>
<text top="700" left="475" width="344" height="9" font="13">[35] L. Mihalkova and R. Mooney. Bottom-up learning of Markov</text>
<text top="712" left="501" width="291" height="9" font="13">logic network structure. In ICML, pages 625–632, 2007.</text>
<text top="726" left="475" width="333" height="9" font="13">[36] L. Mihalkova and M. Richardson. Speeding up inference in</text>
<text top="737" left="501" width="294" height="9" font="13">statistical relational learning by clustering similar query</text>
<text top="749" left="501" width="195" height="9" font="13">literals. In ILP, pages 110–122, 2010.</text>
<text top="763" left="475" width="305" height="9" font="13">[37] T. Park and A. Van Gelder. Partitioning methods for</text>
<text top="775" left="501" width="324" height="9" font="13">satisﬁability testing on large formulas. Automated Deduction,</text>
<text top="787" left="501" width="109" height="9" font="13">pages 748–762, 1996.</text>
<text top="800" left="475" width="346" height="9" font="13">[38] H. Poon and P. Domingos. Sound and eﬃcient inference with</text>
<text top="812" left="501" width="321" height="9" font="13">probabilistic and deterministic dependencies. In AAAI, 2006.</text>
<text top="826" left="475" width="349" height="9" font="13">[39] H. Poon, P. Domingos, and M. Sumner. A general method for</text>
<text top="838" left="501" width="283" height="9" font="13">reducing the complexity of relational inference and its</text>
<text top="850" left="501" width="298" height="9" font="13">application to MCMC. In AAAI, pages 1075–1080, 2008.</text>
<text top="863" left="475" width="350" height="9" font="13">[40] J. Shavlik and S. Natarajan. Speeding up inference in Markov</text>
<text top="875" left="501" width="295" height="9" font="13">logic networks by preprocessing to reduce the size of the</text>
<text top="887" left="501" width="327" height="9" font="13">resulting grounded network. In IJCAI, pages 1951–1956, 2009.</text>
<text top="900" left="475" width="324" height="9" font="13">[41] P. Singla and P. Domingos. Memory-eﬃcient inference in</text>
<text top="912" left="501" width="267" height="9" font="13">relational domains. In AAAI, pages 488–493, 2006.</text>
<text top="926" left="475" width="291" height="9" font="13">[42] P. Singla and P. Domingos. Lifted ﬁrst-order belief</text>
<text top="938" left="501" width="245" height="9" font="13">propagation. In AAAI, pages 1094–1099, 2008.</text>
<text top="951" left="475" width="296" height="9" font="13">[43] B. Taskar, P. Abbeel, and D. Koller. Discriminative</text>
<text top="963" left="501" width="333" height="9" font="13">probabilistic models for relational data. In UAI, pages 485–492,</text>
<text top="975" left="501" width="27" height="9" font="13">2002.</text>
<text top="989" left="475" width="309" height="9" font="13">[44] W. Wei, J. Erenrich, and B. Selman. Towards eﬃcient</text>
<text top="1000" left="501" width="323" height="9" font="13">sampling: Exploiting random walk strategies. In AAAI, 2004.</text>
</page>
</pdf2xml>
